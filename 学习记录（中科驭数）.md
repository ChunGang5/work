---
typora-root-url: images
---

# 学习记录（中科驭数）

# 一、监控

## （一）监控系统的组成

### 1、Prometheus

​	Prometheus是一个开放性的监控解决方案，用户可以非常方便的安装和使用Prometheus并且能够非常方便的对其进行扩展。Prometheus作为一个时序数据库，其实它和大家熟知的Mysql是一类的东西，都是存储数据，提供查询的，它存储了计算机系统在各个时间点上的监控数据。而Grafana仪表盘上的数据，就是通过查询Prometheus获取的。Prometheus主要用于对基础设施的监控，包括服务器(CPU、MEM等)、数据库(MYSQL、PostgreSQL等)、Web服务等，几乎所有东西都可以通过Prometheus进行监控。而它的数据，则是通过配置，建立与数据源的联系来获取的。

**架构图：**

![68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f70726f6d6574686575732f70726f6d65746865757340633334323537643036396336333036383564613335626365663038343633326666643564363230392f646f63756d656e746174696f6e2](D:\桌面\work\images\68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f70726f6d6574686575732f70726f6d65746865757340633334323537643036396336333036383564613335626365663038343633326666643564363230392f646f63756d656e746174696f6e2.svg)

#### （1）来源

​	Prometheus受启发于Google的Brogmon监控系统（相似的Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师在Soundcloud以开源软件的形式进行研发，并且于2015年早期对外发布早期版本。

![2fdc4a155f375cf1958a26bfc991939](/2fdc4a155f375cf1958a26bfc991939-16752417901911.png)

#### （2）优点

① 易于管理

​	Prometheus核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。

② 强大的数据模型

所有采集的监控数据均以指标(metric)的形式保存在内置的时间序列数据库当中(TSDB)。所有的样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。

如下所示：

```c++
http_request_status{code='200',content_path='/api/path', environment='produment'} => [value1@timestamp1,value2@timestamp2...]

http_request_status{code='200',content_path='/api/path2', environment='produment'} => [value1@timestamp1,value2@timestamp2...]
```

每一条时间序列由指标名称(Metrics Name)以及一组标签(Labels)唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。

表示维度的标签可能来源于你的监控对象的状态，比如code=404或者content_path=/api/path。也可能来源于的你的环境定义，比如environment=produment。基于这些Labels我们可以方便地对监控数据进行聚合，过滤，裁剪。

③ 强大的查询语言PromQL

Prometheus内置了一个强大的数据查询语言PromQL。 通过PromQL可以实现对监控数据的查询、聚合。同时PromQL也被应用于数据可视化(如Grafana)以及告警当中。

④ 高效易于集成

对于单一Prometheus Server实例而言它可以处理：

- 数以百万的监控指标
- 每秒处理数十万的数据点。
- 使用Prometheus可以快速搭建监控服务，并且可以非常方便地在应用程序中进行集成。目前支持： Java， JMX， Python， Go，Ruby， .Net， Node.js等等语言的客户端SDK，基于这些SDK可以快速让应用程序纳入到Prometheus的监控当中，或者开发自己的监控数据收集程序

### 2、Grafana

​	是一个监控仪表系统，由Grafana Labs公司开源的的一个系统监测 (System Monitoring) 工具。帮助用户简化监控的复杂度，用户只需要提供需要监控的数据，它就可以生成各种可视化仪表。同时它还支持报警功能，可以在系统出现问题时通知用户。并且Grafana不仅仅只支持Prometheus作为查询的数据库，它还支持如下：

- Prometheus 
- Graphite
- OpenTSDB
- InfluxDB
- MySQL/PostgreSQL
- Microsoft SQL Serve
- 等等

### 3、数据源

​	在Prometheus的架构设计中，Prometheus并不直接服务监控特定的目标，就比如我们监控linux系统，Prometheus不会自己亲自去监控linux的各项指标。其主要任务负责数据的收集，存储并且对外提供数据查询支持。一般是一个Exporter服务提供的。



![1675219007016_AACBEEBB-2E9D-46f0-8F5C-F9AA8D8165E3](D:\桌面\work\images\1675219007016_AACBEEBB-2E9D-46f0-8F5C-F9AA8D8165E3.png)





## （二）Prometheus重要组成部分

### 1、Exporter

​	Exporter是一个相对开放的概念，不是专门指某一个程序。它可以是一个独立运行的程序，独立于监控目标以外(如Node Exporter程序，独立于操作系统，却能获取到系统各类指标)。也可以是直接内置在监控目标中的代码(如在项目代码层面接入普罗米修斯API，实现指标上报)。总结下来就是，只要能够向Prometheus提供标准格式的监控样本数据，那就是一个Exporter。Prometheus周期性的从Exporter暴露的HTTP服务地址(通常是/metrics)拉取监控样本数据。

一般来说可以将Exporter分为2类：

- 直接采集：这一类Exporter直接内置了对Prometheus监控的支持，比如cAdvisor，Kubernetes，Etcd，Gokit等，都直接内置了用于向Prometheus暴露监控数据的端点。
- 间接采集：间接采集，原有监控目标并不直接支持Prometheus，因此我们需要通过Prometheus提供的Client Library编写该监控目标的监控采集程序。例如： Mysql Exporter，JMX Exporter，Consul Exporter等。

后面如果要在我们的C++项目里采集业务数据的话就得去利用间接采集的方法获取数据，可以利用第三方库**[
prometheus-cpp](https://github.com/jupp0r/prometheus-cpp)**

### 2、AlertManager

​	在Prometheus Server中支持基于PromQL创建告警规则，如果满足PromQL定义的规则，则会产生一条告警，而告警的后续处理流程则由AlertManager进行管理。在AlertManager中我们可以与邮件，Slack等等内置的通知方式进行集成，也可以通过Webhook自定义告警处理方式。AlertManager即Prometheus体系中的告警处理中心。

### 3、PromQL

​	Prometheus通过PromQL用户可以非常方便地对监控样本数据进行统计分析，PromQL支持常见的运算操作符，同时PromQL中还提供了大量的内置函数可以实现对数据的高级处理。PromQL作为Prometheus的核心能力除了实现数据的对外查询和展现，同时告警监控也是依赖PromQL实现的。

## （三）样本数据

一般来说访问Exporter暴露的HTTP服务，就能获取到了一系列的监控指标。而这些监控指标便是Prometheus可以采集到当前主机所有监控指标的样本数据。

这是我部署的node Exporter服务的样本数据

![1675157339180_0DD239D4-68EB-4613-B7C9-D820614AC243](D:\桌面\work\images\1675157339180_0DD239D4-68EB-4613-B7C9-D820614AC243.png)

**一条样本数据 = 样本名称（指标）+标签（键值对中的键）+对应的值（右大括号后的值则是该监控样本监控下的具体值）**

#### 1、样本(sample)

Prometheus会将所有采集到的样本数据以**时间序列(time-series)**的方式保存在内存数据库中，并且定时保存到硬盘上。时间序列保存方式是指按照时间戳和值的序列顺序存放，也称之为向量(vector)。 每条时间序列通过指标名称(metrics name)和一组标签集(labelset)命名。如下图所示，可以将向量理解为一个以时间为X轴，值为Y轴的数字矩阵：

![1675157829412_94138C85-22AF-4dc7-9614-E4FA73D34B55](D:\桌面\code\images\1675157829412_94138C85-22AF-4dc7-9614-E4FA73D34B55.png)

在时间序列中的每一个点(即图上的小黑点)称为一个**样本(sample)**，样本由以下三部分组成：

- 指标(metric)：metric name和描述当前样本特征的labelsets，也就是图中的`A{a="x",b="y"}`；
- 时间戳(timestamp)：一个精确到毫秒的时间戳，也就是小黑点对应的x轴的值；
- 样本值(value)： 一个float64的浮点型数据表示当前样本的值，即小黑点对应的y轴的值；

即样本可表示为：

```
A{a="x",b="y"}@1434417560938 => 94355
```

其中1434417560938是时间戳，94355是值。

2、指标（Metric）

在形式上，所有的指标(Metric)都通过如下格式标示：

```js
<metric name>{<label name>=<label value>, ...}
```

指标的名称(metric name)可以反映被监控样本的含义(比如，http*request_total - 表示当前系统接收到的HTTP请求总量)。指标名称只能由ASCII字符、数字、下划线以及冒号组成并必须符合正则表达式[a-zA-Z*:]a-zA-Z0-9_:*。

3.标签(label)

标签反映了当前样本的特征维度，通过这些维度Prometheus可以对样本数据进行过滤，聚合等。标签的名称只能由ASCII字符、数字以及下划线组成并满足正则表达式a-zA-Z_*。

其中以**_作为前缀**的标签，是系统保留的关键字，只能在系统内部使用。标签的值则可以包含任何Unicode编码的字符。

## （四）实操

### 1、使用官方提供的exporter及模板库

监控Linux服务器各项指标和mysql服务各项指标

### 2、自定义

**参考资料：**

prometheus参考书籍：https://yunlzheng.gitbook.io/prometheus-book/

​						https://cloud.tencent.com/developer/article/1769920

​						https://zhuanlan.zhihu.com/p/434353542

​						https://blog.csdn.net/crazymakercircle/article/details/127206293

prometheus git仓库：https://github.com/prometheus/prometheus

linxu防火墙相关操作：https://blog.csdn.net/zhangle416520/article/details/123505280

搭建环境：https://blog.csdn.net/qq_31725371/article/details/114697770

​					https://blog.csdn.net/Zisson_no_error/article/details/125151193

​					https://javaforall.cn/161780.html

​					https://zhuanlan.zhihu.com/p/434353542

自定义绘图：https://blog.csdn.net/admin321123/article/details/127590704

官方提供的仪表盘盘：https://grafana.com/grafana/dashboards/?dataSource=influxdb

告警：https://blog.csdn.net/weixin_45697293/article/details/119606799

​			https://xie.infoq.cn/article/00a968fbb9f0dee487782c1f8

​			https://blog.csdn.net/qq_40492048/article/details/127139122

​			https://blog.csdn.net/weixin_43723044/article/details/122598675

cgo：https://blog.csdn.net/weixin_37871174/article/details/120272449

​		https://zhuanlan.zhihu.com/p/592560633

需要开启pop3协议  密码为验证中后的授权码，qq邮箱客户端-->设置->账户

![image-20230306155839337](/image-20230306155839337.png)

收费的，一条一毛钱，运营商代扣



![image-20230306154045256](/image-20230306154045256.png)



![image-20230306155533502](/image-20230306155533502.png)



![image-20230306155550292](/image-20230306155550292.png)



![image-20230306155613067](/image-20230306155613067.png)



![image-20230306155648276](/image-20230306155648276.png)









# CMake

## 一、基础



# C++11

## 一、消息总线技术

### （一）介绍

​	消息总线技术的目的是简化对象间的复杂关系，降低代码耦合性，将程序员从复杂的对象关系网之中解放出来，提高程序可维护性。

在消息总线中，对象都是通过消息来联系的，消息即对象的关系，我们只需要在消息总线中管理这些消息，而不用关系具体那些对象之间有关联。对象之间只是依赖于某种消息，没有直接的依赖关系，也不需要继承，对象间的耦合也就消除了，两个对象之间没有任何关系。

### （二）关键技术点

#### 1、通用消息的定义

需要一种通用的消息格式，让所有的对象都接受。

#### 2、消息的注册

让所有的对象都可以注册感兴趣的消息。

#### 3、消息分发

通过消息总线分发消息，让所有的接受者都能收到并处理消息。









主备/主从/主主对比
架构	介绍	优点	缺点
主备	
主：主机，备：备机。


主机的意思当然是以它为主了，读写都是主机上，而备机呢就是备用，默默的在背后吸收主机的数据，时刻待命着等待主机挂了之后取而代之(没这么坏哈哈)。

因此在主机还活着的情况下，备机的唯一使命就是同步主机的数据，不对外提供服务。



简单，主备之间只有数据同步，不需要考虑别的情况。就很简单的配置一下，再搞一台服务器就能组成主备架构了。	
备机等于就拿来备份，浪费了备机这台服务器的资源。

上面说的不考虑别的情况指的是主机和备机它们两之间就只要复制数据，但是有些情况我们人还是得考虑的：主机挂了如何让备机上。

有三种选择

1. 人工切换。

人工切换时效性不高，出了事情首先你得开机，登录远程一阵啪啪得好几分钟或者万一你在LOL，黑铁晋级青铜最后一把努力了几个月即将晋升倔强青铜的一刻！是吧。还要万一在深夜或者说....是吧。

2. 引入中间件。

例如ZooKeeper、keepalived。就跟好多房东把房子委托给中介一样，这中间件就是个中介。全权由中介来打理主机和备机，它会根据机子状态来判别这时候是不是该备机上了。(建议)

3. 主机备机之间状态传输(咱不找中介了，自己来打理)

啥意思呢？就是除数据同步，主备之间还要有个状态传输过程，来让备机只要现在主机过得好不好，可以是主机主动推送它的状态给备机，或者是备机去索要状态。当状态拿不到或者不对的时候就开始主备切换。但是可能传输出现了波动啥的，导致备机误判了，然后备机升级为主机，这样就两主机了(下面会说主主的问题)。

主从	
主：主机，从：从机

从机和备机的区别在于它得除了同步数据之外还得干活，对外提供读的操作，你可以理解为它是仆从。

但是仆从和备机一样也有翻身做主人的一天，所以它也在默默的等待着主机挂了，取而代之。



充分利用了资源，嘿嘿不想备机这么爽了，还得出来干活，对外提供读操作。而且在主机挂了的时候，如果没任命新机主之前，读操作还是能用的。

1. 客户端需要多个判断，也就是不同操作需要发放给不同服务器，我上图主机提供读写，有时候读写分离了，主机就提供写。

2. 主从延迟，读操作分配给从库，就会存在数据同步的延迟问题，比如某个人注册了账号之后，登录走的是从机，这时候数据还未从主机同步过来，那可不让人很难受了。有关主从延迟问题的一些解决办法

3. 和主备一样的切换问题。(参考主备)

主主	
主主就是两台都是主机。

同时对外提供读写操作。客户端任意访问提供的一台。



主主的好处就是可以把写操作也分担一下，但是问题恰恰就出在写操作上，导致主主的架构有很大的局限性。

例如主机A有个注册的插入操作，生成的id是50，同一时刻主机B也有个插入操作生成的id也是50。然后它们之间的数据同步了，你说是谁覆盖谁呢？谁覆盖谁都不对！

因此主主只适用于可以双向复制，覆盖的数据(例如用户登录生成的token)。但是我们平日里绝大部分的数据都不允许。








































