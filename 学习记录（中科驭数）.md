---
typora-root-url: images
---

# 学习记录（中科驭数）

# 一、监控

## （一）监控系统的组成

### 1、Prometheus

​	Prometheus是一个开放性的监控解决方案，用户可以非常方便的安装和使用Prometheus并且能够非常方便的对其进行扩展。Prometheus作为一个时序数据库，其实它和大家熟知的Mysql是一类的东西，都是存储数据，提供查询的，它存储了计算机系统在各个时间点上的监控数据。而Grafana仪表盘上的数据，就是通过查询Prometheus获取的。Prometheus主要用于对基础设施的监控，包括服务器(CPU、MEM等)、数据库(MYSQL、PostgreSQL等)、Web服务等，几乎所有东西都可以通过Prometheus进行监控。而它的数据，则是通过配置，建立与数据源的联系来获取的。

**架构图：**

![68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f70726f6d6574686575732f70726f6d65746865757340633334323537643036396336333036383564613335626365663038343633326666643564363230392f646f63756d656e746174696f6e2](D:\桌面\work\images\68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f70726f6d6574686575732f70726f6d65746865757340633334323537643036396336333036383564613335626365663038343633326666643564363230392f646f63756d656e746174696f6e2.svg)

#### （1）来源

​	Prometheus受启发于Google的Brogmon监控系统（相似的Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师在Soundcloud以开源软件的形式进行研发，并且于2015年早期对外发布早期版本。

![2fdc4a155f375cf1958a26bfc991939](/2fdc4a155f375cf1958a26bfc991939-16752417901911.png)

#### （2）优点

① 易于管理

​	Prometheus核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。

② 强大的数据模型

所有采集的监控数据均以指标(metric)的形式保存在内置的时间序列数据库当中(TSDB)。所有的样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。

如下所示：

```c++
http_request_status{code='200',content_path='/api/path', environment='produment'} => [value1@timestamp1,value2@timestamp2...]

http_request_status{code='200',content_path='/api/path2', environment='produment'} => [value1@timestamp1,value2@timestamp2...]
```

每一条时间序列由指标名称(Metrics Name)以及一组标签(Labels)唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。

表示维度的标签可能来源于你的监控对象的状态，比如code=404或者content_path=/api/path。也可能来源于的你的环境定义，比如environment=produment。基于这些Labels我们可以方便地对监控数据进行聚合，过滤，裁剪。

③ 强大的查询语言PromQL

Prometheus内置了一个强大的数据查询语言PromQL。 通过PromQL可以实现对监控数据的查询、聚合。同时PromQL也被应用于数据可视化(如Grafana)以及告警当中。

④ 高效易于集成

对于单一Prometheus Server实例而言它可以处理：

- 数以百万的监控指标
- 每秒处理数十万的数据点。
- 使用Prometheus可以快速搭建监控服务，并且可以非常方便地在应用程序中进行集成。目前支持： Java， JMX， Python， Go，Ruby， .Net， Node.js等等语言的客户端SDK，基于这些SDK可以快速让应用程序纳入到Prometheus的监控当中，或者开发自己的监控数据收集程序

### 2、Grafana

​	是一个监控仪表系统，由Grafana Labs公司开源的的一个系统监测 (System Monitoring) 工具。帮助用户简化监控的复杂度，用户只需要提供需要监控的数据，它就可以生成各种可视化仪表。同时它还支持报警功能，可以在系统出现问题时通知用户。并且Grafana不仅仅只支持Prometheus作为查询的数据库，它还支持如下：

- Prometheus 
- Graphite
- OpenTSDB
- InfluxDB
- MySQL/PostgreSQL
- Microsoft SQL Serve
- 等等

### 3、数据源

​	在Prometheus的架构设计中，Prometheus并不直接服务监控特定的目标，就比如我们监控linux系统，Prometheus不会自己亲自去监控linux的各项指标。其主要任务负责数据的收集，存储并且对外提供数据查询支持。一般是一个Exporter服务提供的。



![1675219007016_AACBEEBB-2E9D-46f0-8F5C-F9AA8D8165E3](D:\桌面\work\images\1675219007016_AACBEEBB-2E9D-46f0-8F5C-F9AA8D8165E3.png)





## （二）Prometheus重要组成部分

### 1、Exporter

​	Exporter是一个相对开放的概念，不是专门指某一个程序。它可以是一个独立运行的程序，独立于监控目标以外(如Node Exporter程序，独立于操作系统，却能获取到系统各类指标)。也可以是直接内置在监控目标中的代码(如在项目代码层面接入普罗米修斯API，实现指标上报)。总结下来就是，只要能够向Prometheus提供标准格式的监控样本数据，那就是一个Exporter。Prometheus周期性的从Exporter暴露的HTTP服务地址(通常是/metrics)拉取监控样本数据。

一般来说可以将Exporter分为2类：

- 直接采集：这一类Exporter直接内置了对Prometheus监控的支持，比如cAdvisor，Kubernetes，Etcd，Gokit等，都直接内置了用于向Prometheus暴露监控数据的端点。
- 间接采集：间接采集，原有监控目标并不直接支持Prometheus，因此我们需要通过Prometheus提供的Client Library编写该监控目标的监控采集程序。例如： Mysql Exporter，JMX Exporter，Consul Exporter等。

后面如果要在我们的C++项目里采集业务数据的话就得去利用间接采集的方法获取数据，可以利用第三方库**[
prometheus-cpp](https://github.com/jupp0r/prometheus-cpp)**

### 2、AlertManager

​	在Prometheus Server中支持基于PromQL创建告警规则，如果满足PromQL定义的规则，则会产生一条告警，而告警的后续处理流程则由AlertManager进行管理。在AlertManager中我们可以与邮件，Slack等等内置的通知方式进行集成，也可以通过Webhook自定义告警处理方式。AlertManager即Prometheus体系中的告警处理中心。

### 3、PromQL

​	Prometheus通过PromQL用户可以非常方便地对监控样本数据进行统计分析，PromQL支持常见的运算操作符，同时PromQL中还提供了大量的内置函数可以实现对数据的高级处理。PromQL作为Prometheus的核心能力除了实现数据的对外查询和展现，同时告警监控也是依赖PromQL实现的。

## （三）样本数据

一般来说访问Exporter暴露的HTTP服务，就能获取到了一系列的监控指标。而这些监控指标便是Prometheus可以采集到当前主机所有监控指标的样本数据。

这是我部署的node Exporter服务的样本数据

![1675157339180_0DD239D4-68EB-4613-B7C9-D820614AC243](D:\桌面\work\images\1675157339180_0DD239D4-68EB-4613-B7C9-D820614AC243.png)

**一条样本数据 = 样本名称（指标）+标签（键值对中的键）+对应的值（右大括号后的值则是该监控样本监控下的具体值）**

### 1、样本(sample)

Prometheus会将所有采集到的样本数据以**时间序列(time-series)**的方式保存在内存数据库中，并且定时保存到硬盘上。时间序列保存方式是指按照时间戳和值的序列顺序存放，也称之为向量(vector)。 每条时间序列通过指标名称(metrics name)和一组标签集(labelset)命名。如下图所示，可以将向量理解为一个以时间为X轴，值为Y轴的数字矩阵：

![1675157829412_94138C85-22AF-4dc7-9614-E4FA73D34B55](D:\桌面\code\images\1675157829412_94138C85-22AF-4dc7-9614-E4FA73D34B55.png)

在时间序列中的每一个点(即图上的小黑点)称为一个**样本(sample)**，样本由以下三部分组成：

- 指标(metric)：metric name和描述当前样本特征的labelsets，也就是图中的`A{a="x",b="y"}`；
- 时间戳(timestamp)：一个精确到毫秒的时间戳，也就是小黑点对应的x轴的值；
- 样本值(value)： 一个float64的浮点型数据表示当前样本的值，即小黑点对应的y轴的值；

即样本可表示为：

```
A{a="x",b="y"}@1434417560938 => 94355
```

其中1434417560938是时间戳，94355是值。

2、指标（Metric）

在形式上，所有的指标(Metric)都通过如下格式标示：

```js
<metric name>{<label name>=<label value>, ...}
```

指标的名称(metric name)可以反映被监控样本的含义(比如，http*request_total - 表示当前系统接收到的HTTP请求总量)。指标名称只能由ASCII字符、数字、下划线以及冒号组成并必须符合正则表达式[a-zA-Z*:]a-zA-Z0-9_:*。

3.标签(label)

标签反映了当前样本的特征维度，通过这些维度Prometheus可以对样本数据进行过滤，聚合等。标签的名称只能由ASCII字符、数字以及下划线组成并满足正则表达式a-zA-Z_*。

其中以**_作为前缀**的标签，是系统保留的关键字，只能在系统内部使用。标签的值则可以包含任何Unicode编码的字符。

## （四）实操

### 1、使用官方提供的exporter及模板库

监控Linux服务器各项指标和mysql服务各项指标

（1）下载并安装exporter

https://prometheus.io/download/

（2）修改Prometheus配置

![image-20230307162205952](/image-20230307162205952.png)

（3）重启Prometheus

（4）打开Prometheus面板，发现已经出现了名为linux的target

![image-20230307162304143](/image-20230307162304143.png)

（5）通过http服务获取到样本数据

http:://101.43.216.36:9100/metrics

![image-20230307164044148](/image-20230307164044148.png)

### 2、自定义

Prometheus 提供了 [官方版 Golang 库](https://github.com/prometheus/client_golang) 用于采集并暴露监控数据，下面让我们来快速的来使用官方库来采集程序内相关的数据，以及其它一些基本简单的示例，并使用 Prometheus 监控服务来采集指标展示数据。

这里有一些官方的客户端库和一些非官方的客户端库，囊括了大部分语言

https://prometheus.io/docs/instrumenting/clientlibs/?spm=a2c4g.11186623.0.0.7efb574dnsOMA2

#### （1）Prometheus 指标的四种类型

① Counter（计数器)

counter metric 是一个只能递增的value

看一下它的接口

```go
type Counter interface {
    Metric
    Collector

    // Inc increments the counter by 1. Use Add to increment it by arbitrary
    // non-negative values.
    Inc()
    // Add adds the given value to the counter. It panics if the value is <
    // 0.
    Add(float64)
}
```

Inc方法，默认+1；Add方法，可以增加自定义的数量。

适用场景：

- 记录不同的API的请求数量
- 记录业务里某个错误码触发数量
- 记录一段时间内风控规则的使用数量

② Gauge

是一个可增可减的指标

接口：

```go
type Gauge interface {
    Metric
    Collector

    // Set sets the Gauge to an arbitrary value.
    Set(float64)
    // Inc increments the Gauge by 1. Use Add to increment it by arbitrary
    // values.
    Inc()
    // Dec decrements the Gauge by 1. Use Sub to decrement it by arbitrary
    // values.
    Dec()
    // Add adds the given value to the Gauge. (The value can be negative,
    // resulting in a decrease of the Gauge.)
    Add(float64)
    // Sub subtracts the given value from the Gauge. (The value can be
    // negative, resulting in an increase of the Gauge.)
    Sub(float64)

    // SetToCurrentTime sets the Gauge to the current Unix time in seconds.
    SetToCurrentTime()
}
```

适用场景：

- 记录服务的内存的占用
- 记录服务CPU的占用
- 记录队列的长度
- 某时刻协议来的数量等

③Histograms（直方图、柱状图）

histograms是一个 直方图度量类型，用于测量落在定义的桶中的数据的值。比如用在测量我们的请求大部分的延迟是落在哪一个区间。这个时候Prometheus不会存储每一次请求所消耗的时间，而是会将每一个请求按照消耗时间看是分配到哪一个bucket。默认的buckets有：**.005, .01, .025, .05, .075, .1, .25, .5, .75, 1, 2.5, 5, 7.5, 10.** 一般来说很少有超过10秒的请求了。当然如果我们有需要，也是可以定制化。

接口：

```go
type Histogram interface {
    Metric
    Collector

    // Observe adds a single observation to the histogram. Observations are
    // usually positive or zero. Negative observations are accepted but
    // prevent current versions of Prometheus from properly detecting
    // counter resets in the sum of observations. (The experimental Native
    // Histograms handle negative observations properly.) See
    // https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations
    // for details.
    Observe(float64)
}
```

使用场景：

- 比如我们的API服务的请求耗时，在所有的bucket分布情况。
- 比如我们消费者处理某个事件的耗时，在所有的bucket分布情况。

④ Summaries（）

**summaries和histograms有很多相似的地方。而不同的地方有以下几点：**

- Histograms 是基于桶来统计数据的，而 Summaries 是基于分位数来统计数据的。
- histograms 分位数的计算是在Prometheus上面，而summaries是在APP服务上就进行了计算。因此summaries也没办法针对多个应用进行聚合。
- summaries适用于需要计算准确的分位数，但不能确定值的范围是什么。

```go
// To create Summary instances, use NewSummary.
type Summary interface {
    Metric
    Collector

    // Observe adds a single observation to the summary. Observations are
    // usually positive or zero. Negative observations are accepted but
    // prevent current versions of Prometheus from properly detecting
    // counter resets in the sum of observations. See
    // https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations
    // for details.
    Observe(float64)
}
```

比如我们的API服务的请求耗时，大部分是落在哪个区间。

#### （2）cgo

Prometheus是go语言写的，官方库也是go、java、python等，没有C和C++官方库，而非官方库prometheus-cpp的使用看起来较为繁琐，不太友好，所以我就直接使用go语言写代码，包装接口，再利用cgo机制，将接口让C程序或者C++程序调用

Go语言通过自带的一个叫CGO的工具来支持C语言函数调用，同时我们可以用Go语言导出C动态库接口给其他语言使用。

## （五）利用Granfana搭建告警系统

我利用qq邮箱向开发人员发送告警邮件

（1）需要开启pop3协议  密码为验证中后的授权码，qq邮箱客户端-->设置->账户

![image-20230306155839337](/image-20230306155839337.png)

收费的，一条一毛钱，运营商代扣

（2）开启smtp配置

![image-20230307190850932](/image-20230307190850932.png)

（2）在Granfana里添加一个告警通道

![image-20230306155533502](/image-20230306155533502.png)

（3）配置一下要接收这个告警邮件的账户

![image-20230306155550292](/image-20230306155550292.png)

（4）测试一下，发送成功了

![image-20230306155613067](/image-20230306155613067.png)



![image-20230306155648276](/image-20230306155648276.png)

（5）设置一个监控项









**参考资料：**

prometheus参考书籍：https://yunlzheng.gitbook.io/prometheus-book/

​						https://cloud.tencent.com/developer/article/1769920

​						https://zhuanlan.zhihu.com/p/434353542

​						https://blog.csdn.net/crazymakercircle/article/details/127206293

prometheus git仓库：https://github.com/prometheus/prometheus

linxu防火墙相关操作：https://blog.csdn.net/zhangle416520/article/details/123505280

搭建环境：https://blog.csdn.net/qq_31725371/article/details/114697770

​					https://blog.csdn.net/Zisson_no_error/article/details/125151193

​					https://javaforall.cn/161780.html

​					https://zhuanlan.zhihu.com/p/434353542

自定义绘图：https://blog.csdn.net/admin321123/article/details/127590704

官方提供的仪表盘盘：https://grafana.com/grafana/dashboards/?dataSource=influxdb

告警：https://blog.csdn.net/weixin_45697293/article/details/119606799

​			https://xie.infoq.cn/article/00a968fbb9f0dee487782c1f8

​			https://blog.csdn.net/qq_40492048/article/details/127139122

​			https://blog.csdn.net/weixin_43723044/article/details/122598675

cgo：https://blog.csdn.net/weixin_37871174/article/details/120272449

​		https://zhuanlan.zhihu.com/p/592560633







# CMake

## 一、基础



# C++11

## 一、消息总线技术

### （一）介绍

​	消息总线技术的目的是简化对象间的复杂关系，降低代码耦合性，将程序员从复杂的对象关系网之中解放出来，提高程序可维护性。

在消息总线中，对象都是通过消息来联系的，消息即对象的关系，我们只需要在消息总线中管理这些消息，而不用关系具体那些对象之间有关联。对象之间只是依赖于某种消息，没有直接的依赖关系，也不需要继承，对象间的耦合也就消除了，两个对象之间没有任何关系。

### （二）关键技术点

#### 1、通用消息的定义

需要一种通用的消息格式，让所有的对象都接受。

#### 2、消息的注册

让所有的对象都可以注册感兴趣的消息。

#### 3、消息分发

通过消息总线分发消息，让所有的接受者都能收到并处理消息。









主备/主从/主主对比
架构	介绍	优点	缺点
主备	
主：主机，备：备机。


主机的意思当然是以它为主了，读写都是主机上，而备机呢就是备用，默默的在背后吸收主机的数据，时刻待命着等待主机挂了之后取而代之(没这么坏哈哈)。

因此在主机还活着的情况下，备机的唯一使命就是同步主机的数据，不对外提供服务。



简单，主备之间只有数据同步，不需要考虑别的情况。就很简单的配置一下，再搞一台服务器就能组成主备架构了。	
备机等于就拿来备份，浪费了备机这台服务器的资源。

上面说的不考虑别的情况指的是主机和备机它们两之间就只要复制数据，但是有些情况我们人还是得考虑的：主机挂了如何让备机上。

有三种选择

1. 人工切换。

人工切换时效性不高，出了事情首先你得开机，登录远程一阵啪啪得好几分钟或者万一你在LOL，黑铁晋级青铜最后一把努力了几个月即将晋升倔强青铜的一刻！是吧。还要万一在深夜或者说....是吧。

2. 引入中间件。

例如ZooKeeper、keepalived。就跟好多房东把房子委托给中介一样，这中间件就是个中介。全权由中介来打理主机和备机，它会根据机子状态来判别这时候是不是该备机上了。(建议)

3. 主机备机之间状态传输(咱不找中介了，自己来打理)

啥意思呢？就是除数据同步，主备之间还要有个状态传输过程，来让备机只要现在主机过得好不好，可以是主机主动推送它的状态给备机，或者是备机去索要状态。当状态拿不到或者不对的时候就开始主备切换。但是可能传输出现了波动啥的，导致备机误判了，然后备机升级为主机，这样就两主机了(下面会说主主的问题)。

主从	
主：主机，从：从机

从机和备机的区别在于它得除了同步数据之外还得干活，对外提供读的操作，你可以理解为它是仆从。

但是仆从和备机一样也有翻身做主人的一天，所以它也在默默的等待着主机挂了，取而代之。



充分利用了资源，嘿嘿不想备机这么爽了，还得出来干活，对外提供读操作。而且在主机挂了的时候，如果没任命新机主之前，读操作还是能用的。

1. 客户端需要多个判断，也就是不同操作需要发放给不同服务器，我上图主机提供读写，有时候读写分离了，主机就提供写。

2. 主从延迟，读操作分配给从库，就会存在数据同步的延迟问题，比如某个人注册了账号之后，登录走的是从机，这时候数据还未从主机同步过来，那可不让人很难受了。有关主从延迟问题的一些解决办法

3. 和主备一样的切换问题。(参考主备)

主主	
主主就是两台都是主机。

同时对外提供读写操作。客户端任意访问提供的一台。



主主的好处就是可以把写操作也分担一下，但是问题恰恰就出在写操作上，导致主主的架构有很大的局限性。

例如主机A有个注册的插入操作，生成的id是50，同一时刻主机B也有个插入操作生成的id也是50。然后它们之间的数据同步了，你说是谁覆盖谁呢？谁覆盖谁都不对！

因此主主只适用于可以双向复制，覆盖的数据(例如用户登录生成的token)。但是我们平日里绝大部分的数据都不允许。







































