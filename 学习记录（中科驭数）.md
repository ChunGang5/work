---
typora-root-url: images
---

# 学习记录（中科驭数）

# 一、监控

## （一）监控系统的组成

### 1、Prometheus

​	Prometheus是一个开放性的监控解决方案，用户可以非常方便的安装和使用Prometheus并且能够非常方便的对其进行扩展。Prometheus作为一个时序数据库，其实它和大家熟知的Mysql是一类的东西，都是存储数据，提供查询的，它存储了计算机系统在各个时间点上的监控数据。而Grafana仪表盘上的数据，就是通过查询Prometheus获取的。Prometheus主要用于对基础设施的监控，包括服务器(CPU、MEM等)、数据库(MYSQL、PostgreSQL等)、Web服务等，几乎所有东西都可以通过Prometheus进行监控。而它的数据，则是通过配置，建立与数据源的联系来获取的。

**架构图：**

![image-20230308111632629](/image-20230308111632629.png)

Prometheus server - 收集和存储时间序列数据
Client Library: 客户端库，为需要监控的服务生成相应的
metrics 并暴露给 - Prometheus server。当 Prometheus server 来 pull 时，直接返回实时状态的 metrics。
pushgateway - 对于短暂运行的任务，负责接收和缓存时间序列数据，同时也是一个数据源
exporter - 各种专用exporter，面向硬件、存储、数据库、HTTP服务等
alertmanager - 处理报警
webUI等，其他各种支持的工具，本身的界面值适合用来语句查询，数据可视化，需要第三方组件，比如Grafana。

#### （1）来源

​	Prometheus受启发于Google的Brogmon监控系统（相似的Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师在Soundcloud以开源软件的形式进行研发，并且于2015年早期对外发布早期版本。

![2fdc4a155f375cf1958a26bfc991939](/2fdc4a155f375cf1958a26bfc991939-16752417901911.png)

#### （2）优点

① 易于管理，无依赖存储

​	Prometheus核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。

② 强大的数据模型

所有采集的监控数据均以指标(metric)的形式保存在内置的时间序列数据库当中(TSDB)。所有的样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。

如下所示：

```c++
http_request_status{code='200',content_path='/api/path', environment='produment'} => [value1@timestamp1,value2@timestamp2...]

http_request_status{code='200',content_path='/api/path2', environment='produment'} => [value1@timestamp1,value2@timestamp2...]
```

每一条时间序列由指标名称(Metrics Name)以及一组标签(Labels)唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。

表示维度的标签可能来源于你的监控对象的状态，比如code=404或者content_path=/api/path。也可能来源于的你的环境定义，比如environment=produment。基于这些Labels我们可以方便地对监控数据进行聚合，过滤，裁剪。

③ 强大的查询语言PromQL

Prometheus内置了一个强大的数据查询语言PromQL。 通过PromQL可以实现对监控数据的查询、聚合。同时PromQL也被应用于数据可视化(如Grafana)以及告警当中。

④ 高效易于集成

对于单一Prometheus Server实例而言它可以处理：

- 数以百万的监控指标
- 每秒处理数十万的数据点。
- 使用Prometheus可以快速搭建监控服务，并且可以非常方便地在应用程序中进行集成。目前支持： Java， JMX， Python， Go，Ruby， .Net， Node.js等等语言的客户端SDK，基于这些SDK可以快速让应用程序纳入到Prometheus的监控当中，或者开发自己的监控数据收集程序

### 2、Grafana

​	是一个监控仪表系统，由Grafana Labs公司开源的的一个系统监测 (System Monitoring) 工具。帮助用户简化监控的复杂度，用户只需要提供需要监控的数据，它就可以生成各种可视化仪表。同时它还支持报警功能，可以在系统出现问题时通知用户。并且Grafana不仅仅只支持Prometheus作为查询的数据库，它还支持如下：

- Prometheus 
- Graphite
- OpenTSDB
- InfluxDB
- MySQL/PostgreSQL
- Microsoft SQL Serve
- 等等

其实 Prometheus 开发了一套仪表盘系统 [PromDash](https://github.com/prometheus-junkyard/promdash)，不过很快这套系统就被废弃了，官方开始推荐使用 Grafana 来对 Prometheus 的指标数据进行可视化，这不仅是因为 Grafana 的功能非常强大，而且它和 Prometheus 可以完美的无缝融合。

安装 Grafana，可以使用最简单的 [Docker 安装方式](http://docs.grafana.org/installation/docker/)：

```shell
$ docker run -d -p 3000:3000 grafana/grafana
```

运行上面的 docker 命令，Grafana 就安装好了！你也可以采用其他的安装方式，参考 [官方的安装文档](http://docs.grafana.org/)。

### 3、数据源

​	在Prometheus的架构设计中，Prometheus并不直接服务监控特定的目标，就比如我们监控linux系统，Prometheus不会自己亲自去监控linux的各项指标。其主要任务负责数据的收集，存储并且对外提供数据查询支持。一般是一个Exporter服务提供的。



![1675219007016_AACBEEBB-2E9D-46f0-8F5C-F9AA8D8165E3](D:\桌面\work\images\1675219007016_AACBEEBB-2E9D-46f0-8F5C-F9AA8D8165E3.png)





## （二）Prometheus重要组成部分

### 1、Exporter

​	Exporter是一个相对开放的概念，不是专门指某一个程序。它可以是一个独立运行的程序，独立于监控目标以外(如Node Exporter程序，独立于操作系统，却能获取到系统各类指标)。也可以是直接内置在监控目标中的代码(如在项目代码层面接入普罗米修斯API，实现指标上报)。总结下来就是，只要能够向Prometheus提供标准格式的监控样本数据，那就是一个Exporter。Prometheus周期性的从Exporter暴露的HTTP服务地址(通常是/metrics)拉取监控样本数据。

一般来说可以将Exporter分为2类：

- 直接采集：这一类Exporter直接内置了对Prometheus监控的支持，比如cAdvisor，Kubernetes，Etcd，Gokit等，都直接内置了用于向Prometheus暴露监控数据的端点。
- 间接采集：间接采集，原有监控目标并不直接支持Prometheus，因此我们需要通过Prometheus提供的Client Library编写该监控目标的监控采集程序。例如： Mysql Exporter，JMX Exporter，Consul Exporter等。

后面如果要在我们的C++项目里采集业务数据的话就得去利用间接采集的方法获取数据，可以利用第三方库**[
prometheus-cpp](https://github.com/jupp0r/prometheus-cpp)**

### 2、AlertManager

​	在Prometheus Server中支持基于PromQL创建告警规则，如果满足PromQL定义的规则，则会产生一条告警，而告警的后续处理流程则由AlertManager进行管理。在AlertManager中我们可以与邮件，Slack等等内置的通知方式进行集成，也可以通过Webhook自定义告警处理方式。AlertManager即Prometheus体系中的告警处理中心。

### 3、PromQL

​	Prometheus通过PromQL用户可以非常方便地对监控样本数据进行统计分析，PromQL支持常见的运算操作符，同时PromQL中还提供了大量的内置函数可以实现对数据的高级处理。PromQL作为Prometheus的核心能力除了实现数据的对外查询和展现，同时告警监控也是依赖PromQL实现的。

#### （1）基本用法

##### ①查询时间序列

当 Prometheus 通过 Exporter 采集到相应的监控指标样本数据后，我们就可以通过PromQL 对监控样本数据进行查询。

当我们直接使用监控指标名称查询时，可以查询该指标下的所有时间序列。如：

```js
prometheus_http_requests_total                  
等同于： 
prometheus_http_requests_total{}     
```

该表达式会返回指标名称为 prometheus_http_requests_total 的所有时间序列

PromQL 还支持用户根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：完全匹配和正则匹配。

➢ PromQL 支持使用 = 和 != 两种完全匹配模式：

⚫ 通过使用 label=value 可以选择那些标签满足表达式定义的时间序列；

⚫ 反之使用 label!=value 则可以根据标签匹配排除时间序列；

![image-20230308171029562](/image-20230308171029562.png)

➢ PromQL 还可以支持使用正则表达式作为匹配条件，多个表达式之间使用 | 进行分离：

⚫ 使用 label=~regx 表示选择那些标签符合正则表达式定义的时间序列；

⚫ 反之使用 label!~regx 进行排除；

例如，如果想查询多个环节下的时间序列序列可以使用如下表达式：

```
prometheus_http_requests_total{environment=~"staging|testing|development",method!="GET
"}
排除用法
prometheus_http_requests_total{environment!~"staging|testing|development",method!="GET
"}
```

##### ②范围查询

直接通过类似于 PromQL 表达式 httprequeststotal 查询时间序列时，返回值中只会包含该时间序列中的最新的一个样本值，这样的返回结果我们称之为瞬时向量。而相应的这样的表达式称之为 瞬时向量表达式。

而如果我们想过去一段时间范围内的样本数据时，我们则需要使用区间向量表达式。区间向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围，时间范围通过时间范围选择器 [] 进行定义。 例如，通过以下表达式可以选择

最近 5 分钟内的所有样本数据：

prometheus_http_requests_total{}[5m]

该表达式将会返回查询到的时间序列中最近 5 分钟的所有样本数据

通过区间向量表达式查询到的结果我们称为区间向量。 除了使用 m 表示分钟以外，

PromQL 的时间范围选择器支持其它时间单位：

```
s - 秒
m - 分钟
h - 小时
d - 天
w - 周
y - 年
```

##### ③时间位移操作

在瞬时向量表达式或者区间向量表达式中，都是以当前时间为基准：

```
prometheus_http_requests_total{} # 瞬时向量表达式，选择当前最新的数据 
prometheus_http_requests_total{}[5m] # 区间向量表达式，选择以当前时间为基准，5 分钟内的数据
```

而如果我们想查询，5 分钟前的瞬时样本数据，或昨天一天的区间内的样本数据呢? 这个时候我们就可以使用位移操作，位移操作的关键字为 **offset**。 可以使用 offset 时间位移操作：

```
prometheus_http_requests_total{} offset 5m
prometheus_http_requests_total{}[1d] offset 1d
```

##### ④使用聚合操作

一般来说，如果描述样本特征的标签(label)在并非唯一的情况下，通过 PromQL 查询数据，会返回多条满足这些特征维度的时间序列。而 PromQL 提供的聚合操作可以用来对这些时间序列进行处理，形成一条新的时间序列：

```
# 查询系统所有 http 请求的总量
sum(prometheus_http_requests_total)
# 按照 mode 计算主机 CPU 的平均使用时间
avg(node_cpu_seconds_total) by (mode)
# 按照主机查询各个主机的 CPU 使用率
sum(sum(irate(node_cpu_seconds_total{mode!='idle'}[5m]))     /     sum(irate(node_cpu_seconds_total [5m]))) by (instance)
```

##### ⑤标量和字符串

除了使用瞬时向量表达式和区间向量表达式以外，PromQL 还直接支持用户使用标量(Scalar)和字符串(String)。

➢ 标量（Scalar）：一个浮点型的数字值

标量只有一个数字，没有时序。 例如：10

需要注意的是，当使用表达式 count(prometheus_http_requests_total)，返回的数据类型，依然是瞬时向量。用户可以通过内置函数scalar()将单个瞬时向量转换为标量。

➢ 字符串（String）：一个简单的字符串值

直接使用字符串，作为PromQL 表达式，则会直接返回字符串。

```
"this is a string"
'these are unescaped: \n \\ \t'
`these are not unescaped: \n ' " \t
```

#### （2）PromQL 操作符

使用PromQL 除了能够方便的按照查询和过滤时间序列以外，PromQL 还支持丰富的操作符，用户可以使用这些操作符对进一步的对事件序列进行二次加工。这些操作符包括：数学运算符，逻辑运算符，布尔运算符等等。

##### ①数学运算

PromQL 支持的所有数学运算符如下所示：

```
+ (加法)
- (减法)
* (乘法)
/ (除法)
% (求余)
^ (幂运算)
```

##### ②布尔运算

 Prometheus 支持以下布尔运算符如下：

```
== (相等)
!= (不相等)
>(大于)
< (小于)
>= (大于等于)
<= (小于等于)
```

#### （3）集合运算符

使用瞬时向量表达式能够获取到一个包含多个时间序列的集合，我们称为瞬时向量。通过集合运算，可以在两个瞬时向量与瞬时向量之间进行相应的集合操作。

目前，Prometheus 支持以下集合运算符：

```
and (并且)
or (或者)
unless (排除)
```

vector1 and vector2 会产生一个由 vector1 的元素组成的新的向量。该向量包含vector1 中完全匹配 vector2 中的元素组成。

vector1 or vector2 会产生一个新的向量，该向量包含 vector1 中所有的样本数据，以及 vector2 中没有与 vector1 匹配到的样本数据。

vector1 unless vector2 会产生一个新的向量，新向量中的元素由 vector1 中没有与vector2 匹配的元素组成。

#### （4）操作符优先级

对于复杂类型的表达式，需要了解运算操作的运行优先级。例如，查询主机的 CPU 使用率，可以使用表达式：

```
100 * (1 - avg (irate(node_cpu_seconds_total{mode='idle'}[5m])) by(job) ) 
```

其中irate 是PromQL中的内置函数，用于计算区间向量中时间序列每秒的即时增长率。在 PromQL 操作符中优先级由高到低依次为：

```
^
*, /, %
+, -
==, !=, <=, =, >
and, unless
or
```

#### （5）PromQL 聚合操作

Prometheus 还提供了下列内置的聚合操作符，这些操作符作用域瞬时向量。可以将瞬时表达式返回的样本数据进行 聚合，形成一个新的时间序列

```
sum (求和)
min (最小值)
max (最大值)
avg (平均值)

stddev (标准差)
stdvar (标准差异)
count (计数)
count_values (对 value 进行计数)
bottomk (后 n 条时序)
topk (前n 条时序)
quantile (分布统计)
```

使用聚合操作的语法如下：

```
<aggr-op>([parameter,] <vector expression>) [without|by (<label list>)] 
```

其中只有 count_values , quantile , topk , bottomk 支持参数(parameter)。

without 用于从计算结果中移除列举的标签，而保留其它标签。by 则正好相反，结果向量中只保留列出的标签，其余标签则移除。通过 without 和 by 可以按照样本的问题对数据进行聚合。

## （三）样本数据

一般来说访问Exporter暴露的HTTP服务，就能获取到了一系列的监控指标。而这些监控指标便是Prometheus可以采集到当前主机所有监控指标的样本数据。

这是我部署的node Exporter服务的样本数据

![1675157339180_0DD239D4-68EB-4613-B7C9-D820614AC243](D:\桌面\work\images\1675157339180_0DD239D4-68EB-4613-B7C9-D820614AC243.png)

**一条样本数据 = 样本名称（指标）+标签（键值对中的键）+对应的值（右大括号后的值则是该监控样本监控下的具体值）**

### 1、样本(sample)

Prometheus会将所有采集到的样本数据以**时间序列(time-series)**的方式保存在内存数据库中，并且定时保存到硬盘上。时间序列保存方式是指按照时间戳和值的序列顺序存放，也称之为向量(vector)。 每条时间序列通过指标名称(metrics name)和一组标签集(labelset)命名。如下图所示，可以将向量理解为一个以时间为X轴，值为Y轴的数字矩阵：



![image-20230308144534704](/image-20230308144534704.png)

在时间序列中的每一个点(即图上的小黑点)称为一个**样本(sample)**，样本由以下三部分组成：

- 指标(metric)：metric name和描述当前样本特征的labelsets，也就是图中的`A{a="x",b="y"}`；
- 时间戳(timestamp)：一个精确到毫秒的时间戳，也就是小黑点对应的x轴的值；
- 样本值(value)： 一个float64的浮点型数据表示当前样本的值，即小黑点对应的y轴的值；

即样本可表示为：

```
A{a="x",b="y"}@1434417560938 => 94355
```

其中1434417560938是时间戳，94355是值。

2、指标（Metric）

在形式上，所有的指标(Metric)都通过如下格式标示：

```js
<metric name>{<label name>=<label value>, ...}
```

指标的名称(metric name)可以反映被监控样本的含义(比如，http*request_total - 表示当前系统接收到的HTTP请求总量)。指标名称只能由ASCII字符、数字、下划线以及冒号组成并必须符合正则表达式[a-zA-Z*:]a-zA-Z0-9_:*。

3.标签(label)

标签反映了当前样本的特征维度，通过这些维度Prometheus可以对样本数据进行过滤，聚合等。标签的名称只能由ASCII字符、数字以及下划线组成并满足正则表达式a-zA-Z_*。

其中以**_作为前缀**的标签，是系统保留的关键字，只能在系统内部使用。标签的值则可以包含任何Unicode编码的字符。

## （四）实操

### 1、使用官方提供的exporter及模板库

监控Linux服务器各项指标和mysql服务各项指标

（1）下载并安装exporter

https://prometheus.io/download/

（2）修改Prometheus配置

![image-20230307162205952](/image-20230307162205952.png)

（3）重启Prometheus

（4）打开Prometheus面板，发现已经出现了名为linux的target

![image-20230307162304143](/image-20230307162304143.png)

（5）通过http服务获取到样本数据

http:://101.43.216.36:9100/metrics

![image-20230307164044148](/image-20230307164044148.png)

（6）创建一个datasource

![image-20230308142444454](/image-20230308142444454.png)

（7）导入官方提供的Dashboard

https://grafana.com/grafana/dashboards/

再添加本次要使用的模板

选择数据源，导入该模板就可以了。

![image-20230308142946413](/image-20230308142946413.png)





### 2、自定义

Prometheus 提供了 [官方版 Golang 库](https://github.com/prometheus/client_golang) 用于采集并暴露监控数据，下面让我们来快速的来使用官方库来采集程序内相关的数据，以及其它一些基本简单的示例，并使用 Prometheus 监控服务来采集指标展示数据。

这里有一些官方的客户端库和一些非官方的客户端库，囊括了大部分语言

https://prometheus.io/docs/instrumenting/clientlibs/?spm=a2c4g.11186623.0.0.7efb574dnsOMA2

#### （1）Prometheus 指标的四种类型

① Counter（计数器)

counter metric 是一个只能递增的value

看一下它的接口

```go
type Counter interface {
    Metric
    Collector

    // Inc increments the counter by 1. Use Add to increment it by arbitrary
    // non-negative values.
    Inc()
    // Add adds the given value to the counter. It panics if the value is <
    // 0.
    Add(float64)
}
```

Inc方法，默认+1；Add方法，可以增加自定义的数量。

适用场景：

- 记录不同的API的请求数量
- 记录业务里某个错误码触发数量
- 记录一段时间内风控规则的使用数量

② Gauge（仪表盘）

是一个可增可减的指标

接口：

```go
type Gauge interface {
    Metric
    Collector

    // Set sets the Gauge to an arbitrary value.
    Set(float64)
    // Inc increments the Gauge by 1. Use Add to increment it by arbitrary
    // values.
    Inc()
    // Dec decrements the Gauge by 1. Use Sub to decrement it by arbitrary
    // values.
    Dec()
    // Add adds the given value to the Gauge. (The value can be negative,
    // resulting in a decrease of the Gauge.)
    Add(float64)
    // Sub subtracts the given value from the Gauge. (The value can be
    // negative, resulting in an increase of the Gauge.)
    Sub(float64)

    // SetToCurrentTime sets the Gauge to the current Unix time in seconds.
    SetToCurrentTime()
}
```

适用场景：

- 记录服务的内存的占用
- 记录服务CPU的占用
- 记录队列的长度
- 某时刻协议来的数量等

③Histograms（直方图、柱状图）

histograms是一个 直方图度量类型，用于测量落在定义的桶中的数据的值。比如用在测量我们的请求大部分的延迟是落在哪一个区间。这个时候Prometheus不会存储每一次请求所消耗的时间，而是会将每一个请求按照消耗时间看是分配到哪一个bucket。默认的buckets有：**.005, .01, .025, .05, .075, .1, .25, .5, .75, 1, 2.5, 5, 7.5, 10.** 一般来说很少有超过10秒的请求了。当然如果我们有需要，也是可以定制化。

接口：

```go
type Histogram interface {
    Metric
    Collector

    // Observe adds a single observation to the histogram. Observations are
    // usually positive or zero. Negative observations are accepted but
    // prevent current versions of Prometheus from properly detecting
    // counter resets in the sum of observations. (The experimental Native
    // Histograms handle negative observations properly.) See
    // https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations
    // for details.
    Observe(float64)
}
```

使用场景：

- 比如我们的API服务的请求耗时，在所有的bucket分布情况。
- 比如我们消费者处理某个事件的耗时，在所有的bucket分布情况。

④ Summaries（）

**summaries和histograms有很多相似的地方。而不同的地方有以下几点：**

- Histograms 是基于桶来统计数据的，而 Summaries 是基于分位数来统计数据的。
- histograms 分位数的计算是在Prometheus上面，而summaries是在APP服务上就进行了计算。因此summaries也没办法针对多个应用进行聚合。
- summaries适用于需要计算准确的分位数，但不能确定值的范围是什么。

```go
// To create Summary instances, use NewSummary.
type Summary interface {
    Metric
    Collector

    // Observe adds a single observation to the summary. Observations are
    // usually positive or zero. Negative observations are accepted but
    // prevent current versions of Prometheus from properly detecting
    // counter resets in the sum of observations. See
    // https://prometheus.io/docs/practices/histograms/#count-and-sum-of-observations
    // for details.
    Observe(float64)
}
```

比如我们的API服务的请求耗时，大部分是落在哪个区间。

#### （2）cgo

Prometheus是go语言写的，官方库也是go、java、python等，没有C和C++官方库，而非官方库prometheus-cpp的使用看起来较为繁琐，不太友好，所以我就直接使用go语言写代码，包装接口，再利用cgo机制，将接口让C程序或者C++程序调用

Go语言通过自带的一个叫CGO的工具来支持C语言函数调用，同时我们可以用Go语言导出C动态库接口给其他语言使用。

![image-20230308105606920](/image-20230308105606920.png)



## （五）利用Granfana搭建告警系统

我利用qq邮箱向开发人员发送告警邮件

（1）需要开启pop3协议  密码为验证中后的授权码，qq邮箱客户端-->设置->账户

![image-20230306155839337](/image-20230306155839337.png)

收费的，一条一毛钱，运营商代扣

（2）开启smtp配置

![image-20230307190850932](/image-20230307190850932.png)

（3）在Granfana里添加一个告警通道

![image-20230306155533502](/image-20230306155533502.png)

（4）配置一下要接收这个告警邮件的账户

![image-20230306155550292](/image-20230306155550292.png)

（5）测试一下，发送成功了

![image-20230306155613067](/image-20230306155613067.png)



![image-20230306155648276](/image-20230306155648276.png)

（6）设置一个监控项

![image-20230307195721762](/image-20230307195721762.png)

![image-20230307195805909](/image-20230307195805909.png)





**参考资料：**

prometheus参考书籍：https://yunlzheng.gitbook.io/prometheus-book/

​						https://cloud.tencent.com/developer/article/1769920

​						https://zhuanlan.zhihu.com/p/434353542

​						https://blog.csdn.net/crazymakercircle/article/details/127206293

prometheus git仓库：https://github.com/prometheus/prometheus

linxu防火墙相关操作：https://blog.csdn.net/zhangle416520/article/details/123505280

搭建环境：https://blog.csdn.net/qq_31725371/article/details/114697770

​					https://blog.csdn.net/Zisson_no_error/article/details/125151193

​					https://javaforall.cn/161780.html

​					https://zhuanlan.zhihu.com/p/434353542

自定义绘图：https://blog.csdn.net/admin321123/article/details/127590704

官方提供的仪表盘盘：https://grafana.com/grafana/dashboards/?dataSource=influxdb

告警：https://blog.csdn.net/weixin_45697293/article/details/119606799

​			https://xie.infoq.cn/article/00a968fbb9f0dee487782c1f8

​			https://blog.csdn.net/qq_40492048/article/details/127139122

​			https://blog.csdn.net/weixin_43723044/article/details/122598675

cgo：https://blog.csdn.net/weixin_37871174/article/details/120272449

​		https://zhuanlan.zhihu.com/p/592560633







# CMake

## 一、基础



# C++11

## 一、消息总线技术

### （一）介绍

​	消息总线技术的目的是简化对象间的复杂关系，降低代码耦合性，将程序员从复杂的对象关系网之中解放出来，提高程序可维护性。

在消息总线中，对象都是通过消息来联系的，消息即对象的关系，我们只需要在消息总线中管理这些消息，而不用关系具体那些对象之间有关联。对象之间只是依赖于某种消息，没有直接的依赖关系，也不需要继承，对象间的耦合也就消除了，两个对象之间没有任何关系。

### （二）关键技术点

#### 1、通用消息的定义

需要一种通用的消息格式，让所有的对象都接受。

#### 2、消息的注册

让所有的对象都可以注册感兴趣的消息。

#### 3、消息分发

通过消息总线分发消息，让所有的接受者都能收到并处理消息。



## 二、高可用

### （一）主备、主从、主主

主备/主从/主主对比
架构	介绍	优点	缺点
主备	
主：主机，备：备机。


主机的意思当然是以它为主了，读写都是主机上，而备机呢就是备用，默默的在背后吸收主机的数据，时刻待命着等待主机挂了之后取而代之(没这么坏哈哈)。

因此在主机还活着的情况下，备机的唯一使命就是同步主机的数据，不对外提供服务。



简单，主备之间只有数据同步，不需要考虑别的情况。就很简单的配置一下，再搞一台服务器就能组成主备架构了。	
备机等于就拿来备份，浪费了备机这台服务器的资源。

上面说的不考虑别的情况指的是主机和备机它们两之间就只要复制数据，但是有些情况我们人还是得考虑的：主机挂了如何让备机上。

有三种选择

1. 人工切换。

人工切换时效性不高，出了事情首先你得开机，登录远程一阵啪啪得好几分钟或者万一你在LOL，黑铁晋级青铜最后一把努力了几个月即将晋升倔强青铜的一刻！是吧。还要万一在深夜或者说....是吧。

2. 引入中间件。

例如ZooKeeper、keepalived。就跟好多房东把房子委托给中介一样，这中间件就是个中介。全权由中介来打理主机和备机，它会根据机子状态来判别这时候是不是该备机上了。(建议)

3. 主机备机之间状态传输

啥意思呢？就是除数据同步，主备之间还要有个状态传输过程，来让备机只要现在主机过得好不好，可以是主机主动推送它的状态给备机，或者是备机去索要状态。当状态拿不到或者不对的时候就开始主备切换。但是可能传输出现了波动啥的，导致备机误判了，然后备机升级为主机，这样就两主机了(下面会说主主的问题)。

主从	
主：主机，从：从机

从机和备机的区别在于它得除了同步数据之外还得干活，对外提供读的操作，你可以理解为它是仆从。

但是仆从和备机一样也有翻身做主人的一天，所以它也在默默的等待着主机挂了，取而代之。



充分利用了资源，嘿嘿不想备机这么爽了，还得出来干活，对外提供读操作。而且在主机挂了的时候，如果没任命新机主之前，读操作还是能用的。

1. 客户端需要多个判断，也就是不同操作需要发放给不同服务器，我上图主机提供读写，有时候读写分离了，主机就提供写。

2. 主从延迟，读操作分配给从库，就会存在数据同步的延迟问题，比如某个人注册了账号之后，登录走的是从机，这时候数据还未从主机同步过来，那可不让人很难受了。有关主从延迟问题的一些解决办法

3. 和主备一样的切换问题。(参考主备)

主主	
主主就是两台都是主机。

同时对外提供读写操作。客户端任意访问提供的一台。



主主的好处就是可以把写操作也分担一下，但是问题恰恰就出在写操作上，导致主主的架构有很大的局限性。

例如主机A有个注册的插入操作，生成的id是50，同一时刻主机B也有个插入操作生成的id也是50。然后它们之间的数据同步了，你说是谁覆盖谁呢？谁覆盖谁都不对！

因此主主只适用于可以双向复制，覆盖的数据(例如用户登录生成的token)。但是我们平日里绝大部分的数据都不允许。

### （二）zk web可视化

https://github.com/zhitom/zkweb

拉取库之后，安装readme.md文档里的提示，直接使用docker的方式安装即可。

启动的时候要有三步：

```shell
# 启动docker
systemctl start docker
# 删除旧docker
docker rm container_id
# 运行docker命令
sudo docker run -p 8099:8099 --name zkweb -d peterpoker/zkweb:v1.2.1
```



### （三）zookeeper c api注意点

### （四）查看zk事务日志

在二进制安装包zookeeper 3.6版本及以上提供了反序列化事务日志的工具，在zookeeper安装目录的bin文件夹下有zkTxnLoglkit.sh这个工具。

```sh
./zkTxnLogToolkit.sh -d log.4c500014df（zookeeper未序列化的事务日志）
./zkSnapShotToolkit.sh -d 快照文件名
```

还有快照读取日志工具

## 三、新特性

### （一）nullptr

在C++98/03中将一个指针初始化为空指针的方法有两种

```c++
char *ptr = 0;
char *ptr = NULL;
```

源码中定义NULL为一个宏

```c++
#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif
```

如果是C++程序NULL为0，如果是C程序NULL为 (void*)0。在 C++ 中，void * 类型无法隐式转换为其他类型的指针，此时使用 0 代替 ((void *)0)，用于解决空指针的问题。这个 0（0x0000 0000）表示的就是虚拟地址空间中的 0 地址，这块地址是只读的。

但是在C++中会有一个bug，在函数重载中NULL和0是无法被区分的。

```C++
#include <iostream>
using namespace std;

void func(char *p)
{
    cout << "void func(char *p)" << endl;
}

void func(int p)
{
    cout << "void func(int p)" << endl;
}

int main()
{
    func(NULL);   // 想要调用重载函数 void func(char *p)
    func(250);    // 想要调用重载函数 void func(int p)

    return 0;
}
/* intput: 
void func(int p)
void func(int p) */
```

所以引入了一个新的关键字nullptr，专门用来初始化空指针。

nullptr 无法隐式转换为整形，但是可以隐式匹配指针类型。在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。

### （二）字符串原始字面量

在 C++11 中添加了定义原始字符串的字面量，定义方式为：R “xxx(原始字符串)xxx” 其中（）两边的字符串可以省略。原始字面量 R 可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。

```c++
string str1 = "D:\hode\test";
string str2 = R"(D:\hode\test)";
string str3 = R"test(D:\hode\test)test"; 
string str3 = R"test(D:\hode\test)str3"; // 语法错误，编译不通过
/* input:
str1 = D:hode   est
str2 = D:\hode\test
str3 = D:\hode\test
*/
```

两边的字符串在解析的时候是会被忽略的，因此一般不用指定。如果在（）前后指定了字符串，那么前后的字符串必须相同，否则会出现语法错误。

### （三）lambda表达式

lambda表达式定义了一个匿名函数，可以简单的捕获一定范围内的变量。

#### 1、语法形式

```c++
[capture] (params) opt -> ret {body};
auto f = [=](int a) -> ret {return a};
auto f = [=](int a){return a+1};
```

其中func 是可以当作lambda 表达式的名字，作为一个函数使用，capture 是捕获列表，params 是参数表，opt 是函数选项
(mutable 之类)， ret 是返回值类型，func_body 是函数体。

 []不捕获任何变量
 [&]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用
 [=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用
 [=, &a]值捕获外部作用域所有变量，按引用捕获a 变量
 [a]只值捕获a 变量，不捕获其它变量
 [this]捕获当前类中的this 指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 & 或者 = ，

#### 2、注意点

```c++
int a = 0;
auto func1 = [=](){return a++}; // 编译error
auto func2 = [=]() mutable {return a++};
```

（1）func1编译不过去是因为我们修改了按值（非this或&，其实就是以复制的方式捕获的）捕获的外部变量，其实lambda表达式相当于一个仿函数，仿函数是一个有operator()成员函数的类对象，这个operator() **默认是 const **的。所以不能修改成员变量，而加了 **mutable**，就是**去掉 const 的属性**。

（2）也可以以引用的方式捕获，可以改变捕获的变量的值。

（3）我们可以认为lambda表达式是一个带有operator()的类，即仿函数。利用std::function 和 std::bind 存储和操作lambda表达式

```c++
std::function<int(void)> f = std::bind([](int a){return a});
```

（4）没有捕获变量的lambda表达式是可以转为一个普通的函数指针，而捕获变量的的lambda表达式则不能转换为函数指针。

因为如果一个已经捕获变量的lambda表达式如果转换为函数指针，那么改lambda表达式自身的this指针就丢失了。因为它的捕获列表中捕获的任何变量，都会变成闭包类型的成员变量。

#### 3、mutable

mutable关键字是一个少用的关键字。而mutable的含义与const正好相反，表明该成员变量属于对象内部`可变`状态，对外不可见。即使在`const`函数也可改变，不影响外部使用者对此`const`函数的逻辑语义。

当成员方法使用const修饰时，我们仍然可以使用其修改mutable修饰的变量。所以，mutable修饰的变量最好是与类的状态无关。

# BRPC

## 一、介绍







## 二、安装难点

![image-20230331111956455](/image-20230331111956455.png)

glags和leveldb耗费了很多时间，原因是centos8在2022年底以及不再维护yum源了，最后leveldb以git拉源码，编译以后将要用的头文件和动态库放到了/usr/include和/usr/lib64这两个文件夹中。gflags采用了dnf方式安装成功。





# 脚本编写

## 一、python

### （一）pyinstaller

PyInstaller是一个用于将Python应用程序和其所有依赖项打包成单个可执行文件的工具。它可以将Python脚本转换为独立的可执行文件，使得你可以在没有安装Python解释器的系统上运行Python应用程序。

使用PyInstaller可以简化Python应用程序的分发和部署过程，使得其他用户可以轻松地运行你的应用程序，而无需手动安装Python解释器和依赖库。常见的使用方法是通过命令行工具来执行PyInstaller。以下是使用PyInstaller的一般步骤：

1. 安装PyInstaller：可以使用pip命令进行安装，例如：`pip install pyinstaller`

2. 在命令行中导航到你的Python脚本所在的目录。

3. 运行PyInstaller命令，指定你的Python脚本文件名，例如：`pyinstaller --onefile your_script.py`

   这将生成一个名为`your_script`的可执行文件，它包含了你的Python脚本及其所有依赖项。

   `--onefile`参数表示将所有文件打包成一个单独的可执行文件，而不是生成多个文件。

4. 执行完上述命令后，PyInstaller将在当前目录中创建一个名为`dist`的文件夹，其中包含了生成的可执行文件。

# 工作收获

## 一、错误点

### （一）&相关

数学&不能判断两个数是否相等

```c++
if (1 & 3)
{
	// 相等
}
```

上段代码是能跑过去的，1(01)&3(11)=(10)，非 0， if判断通过。按位与操作符 `&` 并不能保证两个值在逻辑上相等，只能保证它们在二进制上相等。按位与操作符 `&` 不支持短路，即使其中一个操作数为0，它仍会执行右侧的表达式。不要用按位与操作符进行逻辑相等的判断

### （二）类中有静态成员变量，类对象随程序生命周期自动析构失败

static 修饰的类变量是静态成员变量，不属于类的任何一个对象，所以在类对象析构的时候不会释放静态成员变量。静态成员变量生命周期随程序。

在项目中遇到了一个 bug， 在使用第三方库时，有一个成员变量（指针类型）时第三方库的一个类对象，这个类对象中有静态成员变量，所以在程序停止的时候无法被正常析构掉，所以对于在我们程序的类对象中的成员变量是第三方类，而且这个第三方类中有静态成员变量的这种情况，在程序停止之前我们必须去手动的析构掉这个成员变量，不能用程序终止自动调用析构函数这种方法去析构，因为C++检测到我们这个类对象的成员对象(类类型)中含有静态成员变量，不能去析构，得去手动析构。

### （三）信号量问题导致线程结束不了

代码示例：

```c++
boost::interprocess::interprocess_semaphore msg_queue_sem_{0};  // 消息队列信号量
boost::lockfree::queue<MsgOrderTarget> msg_order_target_queue_{MAX_MSG_QUEUE_SIZE};  // 各模块发送过来的订单指标消息
std::thread*  p_handle_order_statistics_tread_;  // 处理订单各阶段时间戳的线程
volatile bool is_running_=true;
void push_msg_queue()
{
    msg_order_target_queue_.push(msg);
    msg_queue_sem_.post();
}
void stop()
{
    is_running_=false;
    msg_queue_sem_.post();	// 保证在 stop 时候 while 循环不会卡死在 msg_queue_sem_.wait() 这块
    if (p_handle_order_statistics_tread_)
    {
        p_handle_order_statistics_tread_->join();
        delete p_handle_order_statistics_tread_;
        p_handle_order_statistics_tread_ = nullptr;
    }
}
void handle_thread()
{
    while(is_running_)
    {
        msg_queue_sem_.wait();
        if(msg_order_target_queue_.pop(msg))
        {
            // 处理
        }
    }
}
p_handle_order_statistics_tread_ =new std::thread(&handle_order_statistics_tread, this);	// 运行线程
```

其它模块调用push_msg_queue()函数给消息队列 push 一个消息，再调用 post 函数将信号量计数值加1，如果此时有线程在等待该信号量，则唤醒其中一个线程。但是上面的代码会出现一个问题，线程无法结束。

原因：

因为加入了信号量，在要停止的时候，如果恰好消息队列里面没有消息了，则while函数里就会卡在msg_queue_sem_.wait();这块地方，因为信号量为0，它一直在等待信号量>0，才继续往下运行。所以在结束的时候stop函数里要在post信号量，才能保证在程序 stop 的时候 while循环正常往下走wait()这块不等待了，while循环进入下一次判断到is_running_   = false, while循环结束，线程回收，程序正常关闭。

### （五）枚举类型加 const&错误

因为枚举类型会在编译时期被确定，会被映射为一个整数，枚举没有地址，不是一个实际的变量和对象，所以无法被取地址，不能加引用类型，而且加const也没有什么用，它编译时期已经被确定好了。

## 二、收获点

### （一）cvs格式文件如何输出

在做处理订单的性能统计时，我们要记录订单经过各个处理点的时间点，用差值来观测每个处理点的处理效率，但是订单会特别多如果打印到一个log文件里不利于观察，所以我将记录的时间点与各模块处理时间输出到一个 csv 文件里

#### 1、什么是 cvs 文件

CSV文件（Comma-Separated Values，逗号分隔值）是一种常用的电子表格或数据库导出格式，它是一种纯文本格式，以行为单位，每行表示一个数据记录，每个字段之间用逗号分隔。CSV文件可以使用任何文本编辑器打开，也可以使用各种软件工具进行编辑和分析，如Excel、Google Sheets、Python Pandas等。它被广泛用于数据交换、数据存储和数据分析等领域。

打印出的文件内容如下所示：

```
order_id, tp_rc_recv, tp_rc_to_fpga_instruct, tp_fpga_recv_instruct, tp_fpga_return_receipt, tp_rc_recv_fpga_receipt, tp_rc_send, rc_handle_order_time, fpga_handle_order_time, rc_to_fpga_handle_order_time
8589934592, 1682067647521916, 1682067647521916, 1682067647521916, 1682067650522118, 1682067650522122, 1682067650522123, 3000207, 3000202, 3000206
8589934593, 1682067648521979, 1682067648521983, 1682067648521984, 1682067651526625, 1682067651526632, 1682067651526632, 3004653, 3004641, 3004649
2, 1682067649522049, 1682067649522054, 1682067649522054, 1682067652526691, 1682067652526695, 1682067652526695, 3004646, 3004637, 3004641

```

可以用office打开为 execl 文件方便查阅。

C++输出 .cvs 文件代码：

```c++
#include <fstream>
#include <string>
int main() {
	std::ofstream csv_file("file.csv");
    int           a = 1, b = 2, c = 3;
    csv_file << "Field1, Field2, Field3\n";
    csv_file << "Data1, Data2, Data3\n";
    csv_file << a<<", "<< b<<", "<<c<<"\n";
    csv_file.close();
    return 0;
}
```

这个是用 C++ 的 STL 库，基本上就够用了。

### （二）利用观察者解耦多个模块

```c++
class RoleState
{
    // 定义一个存储观察者回调函数列表
    std::vector<std::function<void(int)>> observers_;            // 观察者列表
    int cur_role_state_code_ = 0;	// 定义要通知的信息，可以是一个消息（protobuf）等
    // 添加一个观察者
    inline void add_observer(std::function<void(const int&)> observer)
    {
        observers_.emplace_back(observer);
    }
    // 通知所有观察者
    void notify()
    {
        for (auto& observer : observers_)
        {
            observer(cur_role_state_code_);
        }
    }
};
// 以上可以定义为一个类，最好是一个单例对象，这是一个主题类，内部主题（消息）的变化供观察者列表内的观察者观察
// 使用
class OutPutObserver
{
public:
    void onStateChanged(RoleState state) {
        cout << "System state changed: " << static_cast<int>(state) << std::endl;
    }
};
RoleState role_state;
OutPutObserver          out_put;
role_state.add_observer(std::bind(&OutPutObserver::onStateChanged, &out_put, std::placeholders::_1)); // 
role_state.set_cur_role_state(2);	// 这个set_cur_role_state函数会改变cur_role_state_code_的值，然后调用notify函数，以将cur_role_state_code_的改变信息通知给所有的观察者，换而言之，对于以上代码，观察者列表内的所有观察者都在观察cur_role_state_code_值的改变
// 以上其实是我们利用C++11的std::bind，将类的成员函数指针和一个类对象绑定，然后存放到一个vector列表里，最后通过notify函数调用所有的观察者，也就是调用这些观察者所绑定的成员函数，以达到通知的目的，利用一个观察者对象解除了多个模块间的耦合
```

#### 1、可调用对象

可调用有如下几种定义

（1）是一个函数指针

（2）是一个具有operator()成员函数的类对象（仿函数）

（3）是一个可被转换为函数指针的类对象

（4）是一个类成员（成员函数）指针

#### 2、std::function

`std::function` 是C++11标准库中的一个通用函数封装类模板，它可以用来封装可调用对象（如函数、函数指针、lambda表达式等），并提供统一的调用接口。

但不能容纳类成员函数指针

##### 使用方法：

给std::function填入合适的函数名（即一个函数类型，只需要包括返回值和参数表）

#### 3、std::bind

`std::bind` 函数，可以将成员函数和对象绑定在一起，创建一个可调用对象。

##### 作用：

（1）将可调用对象与其参数一起绑定为一个仿函数

（2）将多元（参数个数n，n>1）可调用对象转成医院或者(n-1)元可调用对象，即只绑定部分参数（那么剩下的未被绑定的参数是否要有默认参数？）

##### 简单例子：

```C++
void output(int i)
{
	std::cout<<i<<endl;
}
std::function<void(int)> f1 = output;	// 定义了一个函数对象f1
auto f2 = std::bind(output, std::placeholders::_1)	// 将函数output绑定到函数对象f2上，std::placeholders::_1表示占位符，表示在调用f2时传入的第一个参数将被传递给output函数。
// 其实f2的类型是std::function<void(int)>，bind最大的好处是可以绑定某个类的对象与其成员函数
// std::placeholders::_2表示占用第二个参数，以此类推

```

#### 4、仿函数

C++中的仿函数（Functor）是一个函数对象，它可以像函数一样被调用。仿函数是一个类或者结构体的实例，通过 **重载** *函数调用运算符* **operator()** 来实现函数的调用

```c++
// 仿函数类
struct MyFunctor {
    void operator()(int value) {
        std::cout << "Value: " << value << std::endl;
    }
};
int main() {
    MyFunctor myFunctor;
    // 通过仿函数对象调用函数
    myFunctor(42);
    return 0;
}
```





# 编程技巧

## 一、语言相关

### （一）使用结构体作为哈希的key

`std::unordered_map` 的键可以是结构体，只要该结构体实现了必要的运算符（如 `operator==` 和哈希函数）。

```C++
#include <iostream>
#include <string>
#include <unordered_map>

struct Person {
    std::string name;
    int age;

    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
};

namespace std {
    template<>
    struct hash<Person> {
        size_t operator()(const Person& p) const {
            return hash<string>()(p.name) ^ hash<int>()(p.age);
        }
    };
}

int main() {
    std::unordered_map<Person, int> ages = {
        {{"Alice", 30}, 30},
        {{"Bob", 40}, 40},
        {{"Charlie", 50}, 50}
    };

    Person p1 = {"Alice", 30};
    auto it = ages.find(p1);
    if (it != ages.end()) {
        std::cout << p1.name << " is " << it->second << " years old.\n";
    } else {
        std::cout << "Person not found.\n";
    }

    Person p2 = {"David", 20};
    it = ages.find(p2);
    if (it != ages.end()) {
        std::cout << p2.name << " is " << it->second << " years old.\n";
    } else {
        std::cout << "Person not found.\n";
    }

    return 0;
}

```

如果结构体包含指针等动态分配的成员变量，则需要自行实现拷贝构造函数、移动构造函数、析构函数等特殊成员函数。否则，可能会发生内存泄漏等问题。

在 `std::unordered_map` 中，键（即 key）是用来确定值（即 value）的存储位置的。在进行键的比较时，`std::unordered_map` 会使用哈希函数来计算键的哈希值，然后根据哈希值找到对应的桶（bucket），再在桶中查找键的位置。

为了让 `std::unordered_map` 能够正确地比较键的值，并根据哈希值查找对应的桶和位置，需要满足以下两个条件：

1. 定义键的相等性：当两个键被认为是相等时，它们应该返回 true。这是为了在查找键值对时判断两个键是否相等。
2. 定义键的哈希函数：该函数应该根据键的内容计算一个哈希值，并且这个哈希值应该能够均匀地分布在哈希表中的所有桶中。这是为了使键能够在哈希表中均匀地分布，从而提高查找效率。

因此，当结构体作为 `std::unordered_map` 的键时，需要定义键的相等性和哈希函数，以便能够正确地比较键的值和计算哈希值。如果没有定义这些函数，编译器将无法对结构体进行比较和哈希计算，导致编译错误。



## 二、性能优化

### （一）内存池

#### 1、工作中遇到的场景

在项目的订单处理性能统计里，用来一个哈希表去存储临时数据，会涉及到对哈希表频繁的插入对象（新增，会new一个键值对，value是一个结构体）和删除对象，所以要对这块进行优化，不能因为要去做性能统计但是却造成了性能下降，这就闹笑话了

#### 2、什么是内存池

内存池（Memory Pool）是一种预先分配一定数量的内存块，并且在需要时从内存池中分配这些内存块的技术。它可以提高程序的效率，减少动态内存分配的开销和碎片问题。

内存池的工作原理是先一次性预先申请一定数量的内存块，然后将这些内存块组成链表或二叉树等数据结构，然后将这些内存块的地址记录下来，并且维护一个空闲链表，用于记录可用的内存块。当程序需要分配内存时，只需从空闲链表中取出一块内存即可，而无需调用动态内存分配函数，从而提高程序的效率。

内存池有多种实现方式，例如位图内存池、固定大小内存池、变长内存池等。

#### 3、实现内存池

### （二）锁粒度检测工具---ThreadSanitizer 

```cmake
313
# ThreadSanitizer 
target_link_libraries(${PROJECT_NAME} -fsanitize=thread)
294
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wreorder -Wcomment -g -O2 -fsanitize=thread -pthread")
```

#### 1、安装

Sanitizers是谷歌发起的开源工具集，包括了AddressSanitizer, MemorySanitizer, ThreadSanitizer, LeakSanitizer，Sanitizers项目本是LLVM项目的一部分，但GNU也将该系列工具加入到了自家的GCC编译器中。GCC从4.8版本开始逐步支持 Sanitizer，这些工具都是查找隐藏Bug的利器

对于已经按照好GCC的centos系统，只需要执行以下命令安装 ThreadSanitizer 库（如果没有安装好GCC就先安装GCC）

```shell
sudo yum install libtsan
```

#### 2、使用

编写代码，以以下参数编译

```shell
g++ -g -O2 -fsanitize=thread test.cc -o example_tsan
```

- `g++`: 是 GNU 编译器集合中的 C++ 编译器。
- `-g`: 启用调试信息的生成。该选项将在可执行文件中包含调试符号，以便在调试过程中能够查看源代码和调试信息。
- `-O2`: 启用优化级别 2。该选项指示编译器进行优化以提高生成的代码的执行效率。
- `-fsanitize=thread`: 启用 ThreadSanitizer (TSan) 功能。ThreadSanitizer 是一种用于检测多线程程序中数据竞争和并发错误的工具。使用该选项会将 ThreadSanitizer 运行时库链接到可执行文件中，并在程序运行时检测潜在的线程安全问题。
- `test.cc`: 要编译的源代码文件。这里假设文件名为 `test.cc`，你可以根据实际情况替换为你的源代码文件名。
- `-o example_tsan`: 指定生成的可执行文件的名称为 `example_tsan`。你可以根据需要更改生成的可执行文件的名称。

综上所述，该命令的作用是将源代码文件 `test.cc` 编译为一个具有调试信息和线程安全检测功能的可执行文件 `example_tsan`。编译后的可执行文件将包含 ThreadSanitizer 运行时库，并在运行时检测多线程程序中的数据竞争问题。





## 三、程序健壮性

### （一）文件处理

1、在操作（每次读取或写入之前）文件时要判断该文件是否存在，是否有读取或写入的权限

2、在main函数里对于传入的参数要做对应的校验，如果传入的参数不对要给出想要的示例。

3、对于每个函数，要在函数头部加入相应的函数注释，函数功能是什么，参数是什么，返回值是什么，参数和返回值的描述可以包括类型和用途。

4、要熟练使用异常捕获，对于可能出现的各种异常要有预处理的策略，这点能大大提高程序的健壮性











































# 工作成果

2023年一月：

1、完成心跳检测基类模块的编写，为后续心跳检测的tcp方式和共享内存方式做好支撑

2、系统状态管理模块设计和编写

3、错误码管理模块的设计和编写，一个 error code 对于中文和英文两种描述

4、在riskcop+connection forward架构下四个节点的高可用模块的设计和编写

5、学习zookeeper，熟悉zookeeper c api，封装项目的C++zookeeper api接口，部署为项目运行环境部署zookeeper server，研究部署zookeeper web可视化工具 

6、为riskcop集合进fd和proxy的新的高可用架构做新的高可用设计方案，编写高可用模块和设计和编写角色管理模块

7、学习华泰rcm库，熟悉稳定，与华泰工作人员对接，将rcm接入riskcop

8、订单性能监控模块的设计和编写，统计一条委托经过风控程序各阶段的耗时情况，导出为csv表格

9、完成Prometheus+Granfana搭建企业级监控告警系统的部门分享

10、写python脚本，删除zookeeper节点的操作

11、完成检测委托回执乱序或缺失方案的设计与需求完成的工作

12、利用ThreadSanitizer工具检查程序资源竞争和锁的粒度，优化代码性能
