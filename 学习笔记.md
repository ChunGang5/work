# 语言部分

## 一、数据结构

### （一）Golang的Map

#### 1、声明和初始化

##### （1）`var m map[string]string`

##### （2）`m:=make(map[string]string,10)`

##### （3）列表初始化

```go
	m:=map[string]string{
		"key1": "v1",
		"key2": "v2",
	}
```

​	当要初始化的hash表中的元素小于或等于25个时，初始化方式与数组或切片一样。

#### 2、增删改查注意点

（1）当给map里存放数据的时候最好先判定map是否为nil（len(m)==0），给nil的map里添加数据会panic

（2）如果要修改的键不存在，map会创建一个新的键值对并存储

（3）删除键值对用delete(m, k)，函数没有返回值，在map为nil，或者要删除的键不存在时不会返回painc，相当于空操作

（4）查询操作

```go
val,ok:=m[k]
if ok{
    fmt.Printf("%v",val)
}else{
    fmt.Println("not exist")
}
```

ps：如果键不存在，那么第一个值为相应类型的零值

这样当v==nil时，就能知道nil是哈希表中存的元素还是表示该键值对不存在了

#### 3、实现原理

##### （1）数据结构

​	Map底层由Hash表实现，一个hash表可以有多个bucket，每个bucket中保存了一个或一组键值对

```go
type hmap struct{
    count	int		//当前map中保存元素的数量，可以很方便的获取len了
    flags	uint8
    B		uint8	//bucket数组的大小
    noverflow	uint16		//溢出桶的近似数量
    hash0	uint32	//hash种子
    
    buckets	unsafe.Pointer	//bucket数组长度，2的B次方（B:1），这就是哈希表真正放数据的地方
    oldbuckets unsafe.Pointer	//用于扩容时保存旧的buckes
    nevacute	uintptr		//
    
    extra *mapextra
}
type mapextra struct{
    overflow *[]*bmap		//存储溢出的数据
    oldoverflow *[]*bmap
    nextOverflow *bmap
}
type bmap struct{
    topshash [bucketCnt]uint8	//这可以看作是一个过渡的数据结构，因为go语言没有泛型，但是map类型可不									是只有一种，具体类型在编译时期推导，重建结构为下面这个结构
}
type bmap struct{
    topbits		[8]uint8		//存储键的高8位值	·
    keys		[8]keytype
    values		[8]valuetype
    pad			uintptr
    overflow	uintptr			//存储溢出的bucket
}
```

​	参考《Go语言设计与实现》这本书，这几个数据结构的关系如下图所示，可以看一下《Go专家编程》这本书，但是书上的Map实现已经过时了，目前的Map实现不是里面讲的那样。

![hmap-and-buckets](https://img.draveness.me/2020-10-18-16030322432679/hmap-and-buckets.png) 

 ![hashmap-mapaccess](https://img.draveness.me/2020-10-18-16030322432560/hashmap-mapaccess.png) 

​																																				 ![hashmap-overflow-bucket](https://img.draveness.me/2020-10-18-16030322432567/hashmap-overflow-bucket.png) 

​	组织一下上面的几幅图，map的整体就可以大致的看到了，连接，溢出，等等。

1、buckets指向的就是哈希的桶，一部分为正常桶，一部分为溢出桶，每个桶能存8个键值对，如果存储的数据过多，就会放在溢出桶里。

2、桶的创建数量通过B得到，如果桶数量多于24，会额外创建2的B-4次方的溢出桶。

3、map的访问：

（1）通过哈希表的哈希函数和种子获取到当前建对应的哈希。

（2）再拿到该键对应的桶序号和哈希的高8位数字

（3）依次这个目标桶和溢出桶的数据

（4）先比较哈希的高8位和桶中的储存的8个tophash，当发现桶中的tophash和传入键的tophash匹配之后，会通过指针和偏移量获取哈希表中存储的键keys[偏移量]并与key比较，如果两者相同，就会获取目标值的指针values[偏移量]并返回

4、写入

（1）跟上面的访问操作一样的步骤，如果找到了这个键的哈希（只是找到了tophash匹配，不管key和value），则返回目标位置的地址

（2）如果当前的键值（就是要写入的key在哈希表中不存在，目标桶中只匹配到了tophash，但是keys数组里灭匹配到），那就说明这个键值对不存在，则将这个键移动到对应的内存空间，并返回对应要放的的value的地址

（3）如果当前桶满了，则会创建新桶或使用预先创建好的溢出桶，新的桶夹在这个桶的末尾，增加hmap的noverflow的计数器

##### （2）扩容机制

扩容发送的情况：装载因子>6.5；哈希表使用了太多的溢出桶

等量扩容

（1）出现场景

​	不断地给哈希表里插入数据，但之后又删除这些数据，装载因子不大，但是溢出桶很多。（装载因子=元素数量 / 桶数量）

（2）一旦哈希表出现了过多的溢出桶，它就会创建新桶保存数据，垃圾收集器清除老的溢出桶并释放数据

翻倍扩容

（1）创建一组新桶和与创建的溢出桶，将原来的桶的数组（buckets）设置到oldbuckets上

（2）将一个旧桶中的数据分到两个新桶上，哪两个新桶呢通过位运算操作

（3）在所有的旧桶被分流后清空哈希表的oldbuckets和oldoverflow

##### （3）遍历操作

### （二）数组和切片

#### 小知识点：

c++:

```C++
extern a; // 声明一个变量，不分配具体的内存（extern改变变量的生命周期；扩大作用域）
int a;	// 定义一个变量，分配内存， 都在栈上，编译器操作
int a = 1;	// 初始化一个变量，分配内存并赋值
a = 2;	//赋值
```

go:

```go

var a int // 定义一个变量，分配内存，变量值为该类型的nil值
var a = 10/int64(10) // 初始化，分配内存并赋值,类型可以指定可可以不指定
```

#### 1、数组和切片的区别

（1）声明和定义上的区别

**ps：只要记住一点，数组需要声明长度，而切片不用！！！**

```go
// 定义
var arr [3]int
var slice []int               // nil 切片, 和 nil 相等, 一般用来表示一个不存在的切片
// 初始化
// 数组
arr1 := [3]int{1, 2, 3}
arr2 := [...]int{1, 2, 3}
// 切片
var slice = []int{} // 空切片, 和 nil 不相等, 一般用来表示一个空的集合，确实分配内存了
slice1 :=[]int{1, 2, 3}
slice2 := make([]int, 10)
slice3 := arr[0, 2]
slice4 := slice1[0, 2]
```

（2）切片的长度是动态，而数组的长度是固定的（编译时期已经确定）

#### 2、数组与切片的相同点

（1）底层都是连续存储的



#### 3、数组的两种初始化方式的区别

```go
arr1 := [5]int{1,2,3,4,5}
arr2 := [...]int{1,2,3} 
```

（1）对于第一种初始化方式来说，编译器在**类型检查**阶段就已经提取出来了数组元素的个数，而第二中方式需要编译器在编译阶段去推导元素的个数然后在创建Array类型的结构体。

```
type Array {
	Elem *Type 
	Bound int64
}
```

两种初始化方式不会影响在运行时期的效率

（2）在初始化字面量时候gc方面的优化

**在不考虑逃逸分析的情况下：**

当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；
当元素数量大于 4 个时，会将数组中的元素放置到静态区然后拷贝到堆上； 

#### 4、切片的基本知识

```go
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```

 uintptr类型（一个整型，足够保证地址的大小范围，32位下4字节，64位下8字节）的Data，其指向一块内存空间，Len表示该切片的长度，Cap表示该切片的容量。其底层和数组一样都是一块连续的存储空间。其实可以这样理解，切片就是对底下数组的一层包装，是对数组的一种引用，我们可以在运行时修改切片的长度和范围，当底层的数组不够时就会触发它的扩容机制 

#### 5、使用字面量创建切片的底层展示

```
slice := [ ]int{1, 2, 3, 4, 5}
```

使用字面量方式创建的切片会在**编译期间**展开，例如 slice := [ ]int{1,2,3,4,5}

```go
var vstat [5]int
vstat[0] = 1
vstat[1] = 2
vstat[2] = 3
vstat[3] = 4
vstat[4] = 5
var vauto *[5]int = new([5]int)
*vauto = vstat
slice := vauto[:]
```

展开步骤：
（1）根据切片中元素的数量对底层数组的大小进行推导并创建数组。
（2）将字面量的值一一存储到初始化的数组中。
（3）创建一个同样类型大小的指针。
（4）将静态区存储的数组赋值给vauto指针所指向区域
（5）使用[ : ]操作获得一个数组。（底层传递类型、数组指针、长度、容量。感觉好像形成了一个闭环）

#### 6、slice的追加

```
slice = append(slice,1)
slice = append(slice, 1, 2, 3) // 可以一次性追加多个元素
```

（1）当cap足够大时，往后面按顺序追加即可

```go
// append(slice, 1, 2, 3)
ptr, len, cap := slice
newlen := len + 3
if newlen > cap {
    ptr, len, cap = growslice(slice, newlen)
    newlen = len + 3
}
*(ptr+len) = 1
*(ptr+len+1) = 2
*(ptr+len+2) = 3
return makeslice(ptr, newlen, cap)
```

如果容量足够大时候，len代表长度，就行c语言中arr[ n]—>*(arr+n)，切片在原有的基础上使用后面的没有被使用的位置存放元素。
（2）当cap不够时，先扩容再追加

```go
//slice = append(slice, 1, 2, 3)
a := &slice			//别忘了切片的结构体是什么样子的了，
ptr, len, cap := slice
newlen := len + 3
if uint(newlen) > uint(cap) {
   newptr, len, newcap = growslice(slice, newlen)
   vardef(a)
   *a.cap = newcap
   *a.ptr = newptr
}
newlen = len + 3
*a.len = newlen
*(ptr+len) = 1
*(ptr+len+1) = 2
*(ptr+len+2) = 3
```

在发生扩容以后，扩容完后的切片的Data、Len、Cap，会覆盖原切片

#### 7、slice的扩容机制

 （1）扩容流程：分配新空间，拷贝旧数据，返回新切片
（2）扩容策略：
如果期望容量大于当前容量的两倍就会使用期望容量；
如果当前切片的长度小于 1024 就会将容量翻倍；
如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量； 

**注意点：golang和C++ vector对于底层实现不一样，golang  Data是一个指针，但是这个指针其实是存了一个真正的切片的底层数组空间，而Data相当于一个变量，它的地址是不变的**

#### 8、Slice的复制

1、切片的复制cope，只会将整块内存的内容复制到目标区域，切片的地址不变。

2、能复制多大的内存要看目的地址有多少空间，如果要把40字节的切片复制给4字节的切片，那么复制完以后，那个4字节的切片大小不变，存放的内容是40字节切片的前4字节。

### （三）字符串

1、是一个连续的内存空间，是由字符组成的数组

2、数据结构

```go
type StringHeader struct {
    Data uintptr
    Len int
}
```

为什么字符串没有cap，是因为字符串是只读类型，字符串的写入都是通过复制实现的，直接复制底层的data指针的指向位置和len。

## 二、golang的可变参数

### （一）声明

在参数类型前加”...”前缀：func(a interface{}，params ...interface{})

### （二）使用注意点

1、可变参数必须在函数参数列表的尾部

2、可变参数在函数内部实际时作为切片来解析的

一个工作中遇到的实际场景：给一个定义的protobuf消息内传可变参数，其中这个消息内一个字段类型为repeted（表示该字段可以包含0~N个元素），可以看作是在传输一个数组，这正好与golang的可变参数对应上使用。

3、可变参数可填可不填，不填情况下按照nil切片来处理

4、可变参数必须是相同的类型，如果需要不同的类型可以定义为interface{}类型

5、在调用可变参数函数时，可变参数部分可以直接传一个切片（test(a,params...)）

但切片出入的时候是值传递，传递的是这个切片的地址，不会生成新切片，函数内部使用的切片和传入的切片使用同一块内存空间，改变内部切片值外部的值会随之改变

## 三、golang的交叉编译

### （一）linux上编译为win

CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build

### （二）win上编译为linux

SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go

### 参考文章：

https://studygolang.com/articles/14376

## 四、Golang的并发编程

### （一）channel

#### 1、概述

Channel通信是在Goroutine之间进行同步的主要方法。它能利用无缓冲管道的阻塞式读写的他特点实现两个goroutine之间通信的同步。（在同一个Gorutine上执行两个操作和容易造成死锁）。

#### 2、使用

（1）使用无缓冲channel来实现同步机制，一般主进程或协程读或写都可以。

**原因：**对于无缓冲的channel来说读写都是阻塞式的。Go语言内存模型规范，对于无缓冲的channel进行的接收，发生在对该channel的发送完成之前。（因为读写都是阻塞式的，读完肯定在发完之前）

（2）更为安全的同步方式，主进程读，协程写。

**原因**：i：如果是带缓冲的channel。因为有缓冲区，主进程可能会直接发送到缓冲区，主进程执行完毕，而协程才开始执行，无法保证主进程推出之前，协程能正常打印。

```go
func main() {
	done := make(chan int)

	go func(){
		fmt.Println("你好, 世界")
		<-done
	}()

	done <- 1
}
```

**解决方式：**将读写调换，主进程读，协程写。对于带缓冲的channel的第K个接受完成操作发生在第K+C个发送操作之前（C是channel的缓冲区大小）。*ps：这段话我感觉不太对，还没有验证。看《Go语言设计与实现》里如果缓冲区为nil，可以直接发送，接收端直接读，怎么会发生读K，发了K+C个？*

***个人猜想*：**带缓冲的channel的发送操作在缓冲区未满之前是非阻塞式的，接受是阻塞式的，如果将接收操作放在协程里，可能channel发送完之后直接就结束了，协程的信息根本来不及打印。

#### 3、特点

（1）带缓冲和不带缓冲的channel都遵循先进先出的形式发送和接收数据。

（2）channel中自带的互斥锁的作用其实大部分是保护成员变量，而不是用于再goroutinhe读写数据时加的，而goroutine读写数据时可以基于原子指令CAS（compare-and-swap或compare-and-set）再多线程中同步数据。

#### 4、数据结构

```go
type hchan struct{
    qcount		uint	// channel中的元素个数
    dataqsiz	uint	// channel中循环队列的长度
    buf			unsafe.Pointer	// channel中缓冲区数据指针
    elemsize	uint16	// channel能收发的元素的大小
    closed		uint32
    elemtype	*_type	// channel能收发的元素的类型
    sendx		uint
    recvx		uint
    recvq		waitq	// 存储因为缓冲区不足而阻塞的要读取缓冲区数据的goroutine列表（猜测可能是数据不							足） 
    sendq		waitq	//	存储因为引缓冲区空间不足而阻塞的向缓冲区内发送数据的goroutine列表
    lock 		mutex
}

// 双向链表
type waitq struct{
    first *sudog
    last  *sudog
}
// sudog表示一个再等待列表中的goroutine
```

#### 5、面试注意点

1、管道是golang在goroutine之间同步的主要方式，基于无缓冲管道的阻塞式读写方式，遵循先进先出原则

2、对于只声明，没make的nil管道，读写操作都会出发panic

3、对于无缓冲管道，buf不会给分配，对于有缓冲管道会分配buf，buf指向一个双向循环数组

4、发送数据

（1）对于有待接收者时，通过runtime.send直接发送给阻塞的接收者

（2）对于缓冲区存在且有空余空间，将发送数据写入管道的缓冲区

（3）当不存在缓冲区或缓冲区满了，会等待其他goroutine接收数据

5、异步管道就是基于环形缓冲区的生产者消费者模型

6、读管道有两个返回值v,ok:=<-ch

7、关闭管道

（1）先加锁，将所有挂在这个管道上的sendq和recvq上的sudog连城一个链表，再解锁

（2）再将这个链表上的所有的sudog全部唤醒

（3）这时管道已经关闭了，发送的sender检测到管道关闭，panic。接收者还可以读到缓冲区里的数据。如果没有数据了，则会读到对应数据类型的零值。

![1661745890045](D:\桌面\work\images\1661745890045.png)

8、对于同一协程，无缓冲管道不能同时进行读写操作。

### （二）WaitGroup

#### 1、概述

WaitGroup可以理解为Wait Goroutine Group，意为等待**一组**goroutine结束。

#### 2、使用

##### （1）声明一个WaitGroup，var wg *sync.WaitGroup

##### （2）wg.Add( )

##### （3）wg.Done()

##### （4）wg.Wait()

#### 3、个人理解

WaitGroup就相当于Linux并发编程那里学过的信号量

#### 4、注意点

1、wg不能被拷贝，因为golang是值拷贝，举个例子，如果在外层函数add了，但是在内层函数done，那么就会wait陷入死锁，因为内层函数拿到的是wg的拷贝，done的是副本。

### （三）Context

1、作用

在不同的Goroutine之间同步信号、设置截止日期，传递特定数据

2、使用注意点

（1）context.Background()会返回一个无法被取消的一个context，没有值，不会过期，把它看作一个基类context就行了，注意点不多

（2）使用context.WaitCancel()会返回一个cancle函数用来取消新生成的子context，只不过注意一下context的继承链，*书上有方式P190页*

3、主要元素

Deadline、Done、Err、Value

### （四）锁

#### 1、sync.Mutex

是go里面的互斥锁，由两个字段构成

```go
type Mutex struct {
    state int32
    sema  uint32
}
```

state表示锁的当前状态低三位从左往右依次是mutexStarving(饥饿)、mutexWoken(正常模式先进先出)、MutexLocked(锁定状态)。剩下位表示当前多少goroutine在等待锁释放。

#### 2、自旋状态

当没有获取到锁时该线程等待式的、循环尝试去加锁，知道持有锁的线程释放锁之后才能获取到。

优点：减少用户态和内核态之间的转换（不然的话该进程就要阻塞再唤醒：用户-内核-用户）

缺点：如果持有锁的线程占有时间过长，则处于自旋状态的线程一直占用cpu，则自旋的消耗大于线程状态切换的消耗（解决方式，给自旋状态加一个时间）

#### 3、几种锁的总结



#### 4、问题

mutex如何避免饥饿问题？

### （五）调度器

1、GMP模型

​														Global runqueue：g---g---g---g（用链表实现的，无限制）

![1661760319410](D:\桌面\work\images\1661760319410.png)

​																											runqueues

G：goroutine，是待执行的任务，数量受内存限制

M：操作系统的线程（真正干活的），由操作系统的调度器调度和管理

P：处理器，在线程上运行的本地调度器，是M和G的中间层，存放M要执行的g的所需要的上下文，也会负责调度线程上的等待队列

GMP这三个部分共同组成golang的调度器。它的作用就是能更好地将可运行的goroutine分配到工作线程上。

GMP的全局对列和P的本地对列都是存放等待运行的g

全局队列和本地队列知识：

1、新建的g会优先存放在p的本地队列，如果满了，会拿出一半放到全局队列

2、如果P的队列空了，M会从全局队列里拿一批放到P的本地队列，或者从其他P的本地队列偷拿一半放到自己P的本地队列里。M运行G，完了以后会再从P的本地队列拿一个g，不断重复

#### 面试问题

1、goroutine默认栈空间大小为2k-4k。默认情况下会创建cpu核数对应的活跃的操作系统线程数，一个活跃的操作系统线程对应一个运行中的M。

2、M最多可以创建10000个线程（最多10000个M），但是大多数会陷入系统调用，不会执行用户代码。可以用SetMaxThreads函数设置。M不够用的话，p会创建新的M

3、P通过GOMAXPROCS设置活跃的线程数，P的本地队列队都有256个g，

4、协程是轻量级的线程，不受操作系统调度，协程调度器由用户程序提供（P？）

5、g0是持有调度栈的goroutine，每一个m只有一个g0，执行调度任务，curg是在当前线程上运行的用户goroutine

6、什么是m0，什么是g0？

m0是Go runtime创建的第一个系统线程，一个Go进程只有一个m0，也叫主线程（tgid），可以和linux下进程创建联系起来，task_struct结构体，内存指针指向进程的地址空间，有独立的栈空间。

7、什么是协程，协程是一种轻量级线程，由用户态操作切换，不会陷入内核态。

8、P和M什么时候被创建

P在程序运行起来的时候根据GOMAXPROCS知道了数量，就会创建这么多的p

M是在运行时，当一些M阻塞了，但是还有很多P上有很多待执行的g，那么P就回去寻找空闲的M，如果没有就创建新的M。

9、当阻塞的M将它执行的G从系统调用出来了以后会怎么做（这个GM组合只是当初在陷入系统调用的时候剥离了P，后续还得执行这个G）

（1）当M的系统调用结束以后，这个G会尝试获取一个空闲的P来继续执行它，并将G放入P的本地队列。

（2）如果获取不到，会将G加入到全局队列，M会被变成休眠线程

10、GMP模型的优点：

（1）避免频繁的创建和销毁线程，也避免了操作系统因为某一时刻线程数过多，调度代价太高。因为创建的M不会被销毁，它在没有可运行的g时会尝试从其他M绑定的p上偷g

（2）当M陷入阻塞是，会释放绑定的p，将p给其它空闲的M去执行

**GMP的生命历程：**

![1661877740717](D:\桌面\code\images\1661877740717.png)

11、自旋线程是一个唤醒的M它绑定了一个P，但是这个P的本地线程没有G，那么M、G0和P在循环运行，并不断地寻找待运行的G。处于自旋状态的线程最大数量为GOMAXPROCS。M与P的数量关系是M>=P，因为可能有一些M陷入了系统调用。

### （六）垃圾回收器

#### 发展历程

1、go1.3标记---清除法：

（1）标记阶段：从根对象出发查找并标记堆中所有存活的对象

（2）清除阶段：遍历堆中的所有对象，回收未标记的垃圾对象并将回收的内存加入空闲链表

缺点：STW（ stop the world ）。在垃圾回收过程中要暂停用户程序，程序出现卡顿

go1.5三色标记法

​	白色对象：潜在的垃圾，其内存可能会被垃圾回收器回收

​	灰色对象：活跃的对象，一个暂存的东西吧，用来找黑色对象的

​	黑色对象：活跃的对象

（1）将所有的对象放入白色集合中

（2）将根节点放入灰色集合，从跟节点开始遍历，将遍历到的白色对象放入灰色集合，同时将该灰色对象放入黑色集合，重复遍历灰色集合，直到灰色集合没有对象

（3）垃圾回收器回收掉白色集合

优点：减少了STW的时间

带来了一个新的问题：悬挂指针

如果不用STW，在标记的后期，一个黑色对象指向了一个白色对象，这个白色对象就会被错误的回收掉。

解决方式：屏障机制

强三色不变性：黑色对象不会指向白色对象

弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径

实现方式：读屏障和写屏障

（1）插入写屏障

将黑色对象指向的白色对象改为灰色

缺点：可能会有多余的灰色对象，导致一些该回收的对象不能被回收掉

（2）删除写屏障

![1662619831164](D:\桌面\work\images\1662619831164.png)

增量和并发

增量垃圾收集：增量的标记和清除垃圾，降低应用程序暂停的最长时间

并发垃圾收集：利用多核的计算资源，在用户程序执行时并发标记和清除垃圾









## 五、定时器

### Timer

一次性定时器，一种单一时间定时器。经过特定时间后触发一个事件，计时结束旧停止运行，最多只运行一次。

### Ticker

周期性定时器，定时器周期性的进行计时，周期性的触发一个事件，除非主动停止，否则将永久运行。

### 数据结构

timer和ticker的数据结构完全一样

```go
// timer
type Timer struct {
	C <-chan Time	// 用户层用
	r runtimeTimer	// 系统层面用，对外不可见
}
type Ticker struct {
	C <-chan Timer
	r runtimeTimer
}
```

**重要：**

runtimeTimer的数据结构

```go
type runtimeTimer struct {
	pp       uintptr	// 存储在对应处理器的最小四叉堆的地址
	when     int64		// 当前计时器要被唤醒的时间
	period   int64		// 两次唤醒的时间间隔，只有ticker用
	f        func(interface{}, uintptr) // NOTE: must not be closure，计时器被唤醒时调用的函数
	arg      interface{}	// 传入f的参数1
	seq      uintptr	// 参数2（只在网络收发的场景下用）
	nextwhen int64		// 计时器处于 timerModifiedXX 状态时，用于设置 when 字段
	status   uint32		// 计时器的状态
}
```

### 两种计时器的的区别

#### （一）相同点

1、底层数据结构完全一样，Time和runtimeTimer

2、底层调用的函数也一样startTimer、stopTimer、resetTimer、modTimer等

3、C这个管道的大小都初始化为1，管道写入事件永远不会被阻塞。这块是给sendTime()这个函数用的

#### （二）不同点

1、NewTimer()函数创建一个*Timer时不初始化runtimeTimer结构体中的period字段。而NewTicker()函数会初始化period : int64(d)

2、timer的Stop()函数会返回一个bool值，true表示超时前停止，后续不会再发送事件了。false表示超时后停止，事件已经发送了。其实和ticker的Stop()函数底层调用的都是stopTimer()函数

#### （三）注意点

1、定时器使用完以后要释放，否则会产生内存泄漏。显式调用Stop()函数以后管道并不会被关闭，防止用于协程读写出错，管道在使用完以后，生命周期结束会自动释放。**这块其实针对的是Ticker**，因为它是周期性的，如果不显式调用Stop()那么系统监控协程将持续监控该Ticker的timer，资源大大浪费。timer的数量是一定的，一般是64个。

2、Ticker由于C的大小为1，含有一个缓冲区，但是Ticker的触发是周期性的，所以当管道中的数据没有被取出时，sendTime也不会被阻塞，本次要触发的事件直接丢失。

```go
func sendTime(c interface{}, seq unitptr) {
select {	// select检测管道是否可读或可写，如果可以，就进入这个case
	case c.(chan Time) <- Now():
	default:	// 这样写就不会阻塞了
	}
}
```

### 触发计时器

#### 调度器

作用：检查处理器中的计时器是否准备就绪

#### 系统监控

作用：检查是否有未执行的到期的计时器

## 六、常用关键字

### defer

数据结构为单链表串联起来，头插--->头删实现先进先出的类似于栈的方式

#### （一）常用场景

##### 1、延后关闭资源

文件描述符、数据库、网络套接字、解锁等

##### 2、延后执行函数

#### （二）使用注意点

1、不仅函数正常返回（例如main函数结尾处的return）会执行被defer延迟的函数，函数中任意一个return、panic都会触发延迟函数

2、延迟函数的参数在defer语句出现时的就已经确定了。

这个变量的值在走到defer处已经确定了，后面再改变值也不影响。但是如果记录的是变量的地址的话就另当别论了，会打印出该地址内部的值，如果后面变量值被改变了，则打印出最新的数据。

3、延迟函数按照后进先出的顺序执行。defer函数本身也跟一个普通函数一样，也可以定义defer语句。一个函数要执行在该函数的末尾才会去执行下一个函数。

```go
func foo(){
	defer func(){
		defer func(){
			fmt.Println("B")
		}()
		fmt.Println("A")
	}()
}
```

结果为：AB

原因：别想太多，foo函数内遇到defer把它先记录起来，执行到foo末尾转而去执行外层的defer函数。而第一个defer函数在执行时内部也定义了一个defer，先记录起来，继续执行，打印出A，执行到函数末尾，开始去执行第二个defer，打印出B，第二个defer函数返回--->第一个defer函数ret--->foo函数ret，执行结束。

4、要注意延迟函数可能会操作主函数的具名返回值

defer 执行一个函数。主函数拥有具名返回值，内部函数操作剧名返回值

```go
func foo()(ret int){
    defer func(){
      ret++  
    }()
    return 0      // ret=1
}
```

原因：执行流程可以拆分为 ret=0 ；ret++; return。因为return并不是原子操作的，return只代表汇编指令ret，即跳转的意思。比如上面的return 0；就可以拆分为两部，先将 0 存在栈中，然后ret被赋值为0。但是defer在return之前。那就变成了上面是所说的三步了。

详细点说：

（1）、return 0：将0存入寄存器，ret=0

（2）、执行defer部分，ret++，ret==1）

（3）、真正return函数返回，但此时ret以及变成1了

5、当出现 panic 语句的时候，会先按照 defer 的后进先出的顺序执行，最后才会执行panic。 

#### （三）性能优化

1、每个defer会实例化为为一个_defer结构的实例，这个实例里大致存放了执行函数所必须的信息：栈地址、程序计数器、函数地址、还有一个用于连接其他defer示例的指针。

2、多个_defer实例link起来成一个单链表，存放到goroutine数据结构里

3、在src/runtime包里有两个方法，一个将defer实例化为一个_defer放在goroutine里，另一个将defer从goroutine里的链表里取出defer示例执行。

堆存储defer---->栈存储defer---->开放编码

4、最终的解决方法开放编码，其实就像C++的内联函数，直接将代码加在后面减少函数调用的开销。

### for 和 range

#### （一）是什么

for和range是go语言的两个关键字，分别用于循环和遍历。for-range结构是go语言中的一种**范围循环结构**，能帮助我们快速的遍历一些数据结构。**for经典循环**和**for-range范围循环**在go的编译器层面都被解释为相同的汇编代码，使用for-rang的控制结构最终也会被go语言编译器转换成普通的for循环。

#### （二）特点

1、range在循环开始之前就已经确定了循环次数

2、对数组和切片底层是一样的，相对于经典for循环，无非是range多了一层元素数量的计算环节

3、对于map的遍历是无序的？为什么呢？

答：遍历的时候会通过src里面的一个**fastrand()**函数生成一个随机数，来随机的选择遍历桶的起始位置。

ps：因为对于map的插入是无序的**（这块去map实现那一节看一下）**，所以在循环遍历map时插入的元素可能是遍历不到的。

4、对于range返回值的个数，除了遍历channel时最多返回一位**（因为channel没有下标的概念**），其它都是最多返回两个，可以最多省略一个。

5、range会阻塞等待channel中的数据，直到channel被关闭。所以遇到nil的channel是会永久阻塞。

6、对对于数组、切片、哈希这种内存空间连续的数据结构，在清空的时候是直接清空那块内存的，go的源码会调用一个函数用来清空。

#### （三）易错点

1、for-range的k-v结构在源码底层的实现是将一个变量当作v，所以不论循环多少次都是同一个v，只是v里存的值不同，所以在将v存放进一个指针数组里的时候，最后该数组内的值都相同

```go
func main() {
	arr := []int{1, 2, 3}
	newArr := []*int{}
	for _, v := range arr {
		newArr = append(newArr, &v)	// 正确应该是&arr[i]
	}
	for _, v := range newArr {
		fmt.Println(*v)
	}
}
// 输出：3，3，3
// 源码
ha := a
hv1 := 0
hn := len(ha)
v1 := hv1
v2 := nil
for ; hv1 < hn; hv1++ {
    tmp := ha[hv1]
    v1, v2 = hv1, tmp
    ...
}
```

### select

#### （一）作用

1、能够让Goroutine同时等待（阻塞式等待）或监听多个channel的可读或可写状态。

2、对于同时处于可读或可取的多个管道（即多个case条件同时被触发），select随机执行一个。而随机处理的目的一般都是为了避免饥饿问题。

#### （二）注意点

1、select虽然看起来与switch相似，但是select的case中的表达式必须是channel的收发操作。

2、对于nil(未初始化的管道)管道，既不可读也不可写，如果没加default处理，那么会永久陷入等待阻塞之中。

#### （三）数据结构

select关键字在go语言源码里并没有对应的结构体，其控制结构中的case是有描述的，是src/runtime/select.scase结构体

```go
type scase struct{
	c *hchan	//hchan是channel的数据结构
	elem unsafe.Pointer		// data element
}
```

#### （四）四种场景

1、空的select

由于select中没有任何的case，select{}会转换成直接调用runtime.block()，直接阻塞当前的goroutine，导致goroutine进入无法被唤醒的永久休眠状态。

2、单一管道

如果管道是nil的那么直接就会陷入阻塞状态。如果不是nil管道但是没有达到case条件，一段时间以后也会陷入永久休眠状态，导致程序退出。一个case编译器会直接把select优化未if语句。

空select、单一nil管道、单一非nil管道但case无法达到条件都会导致程序退出，出现

​		fatal error: all goroutines are asleep - deadlock! --->死锁

不同的是nil管道错误会提示nil channal。

ps：为什么陷入阻塞状态程序会报出现死锁错误？这是因为go语言死锁检测发现当前的goroutine已经不可能再被唤醒，就会直接报错退出。

3、非阻塞（包含default）

编译器会将这种情况优化为if else语句，程序永远不会陷入阻塞。

4、多个case

如果有多个case符合条件了，那么会随机选择一个执行。

### make和new

#### （一）作用

make是创建切片、哈希表和channal等内置的数据结构的关键字

new为类型申请一片内存空间，并返回指向这片内存的指针。

### panic和recover

panic()是一个内置函数，可以接收任意类型的参数，能显式得触发程序异常。也会在Go程序运行的时候触发（越界访问）

1、panic会递归的执行协程中所有的defer，与函数正常退出defer的执行顺序一致

2、painc不会处理其他协程中的defer，执行的只有当前goroutine中的defer

3、当前协程中的defer处理完成后，触发程序退出

3、当前协程中的defer处理完成后，触发程序退出

4、panic调用后会立即停止执行当前函数的剩余代码

recover()是一个内置函数，用于消除panic并使程序恢复正常

1、recover必须结合defer使用，必须直接位于当前函数的defer中，不能是这个函数的闭包中。

2、一个panic只会被recover一次

3、recover函数成功处理异常以后，无法再次回到本函数发生panic的位置继续执行

4、recover可以消除本函数产生或收到的panic，上游函数感知不到panic的存在

**问题：**

1、为什么recover要在defer里？

要保证recover要在panic之后执行，如果recover没有在defer中而且在panic之前，那么panic不会被recover消除

2、recover的返回值？

如果当前的goroutine没有调用panic，那么该函数会直接返回nil。否则为接收的panic里的值（字符串啥的）





## 七、内存管理

#### 小知识点：

##### 1、闭包

闭包就是能够读取所包含它的函数的内部变量的函数，有些是值传递，有些是引用，具体看语言实现者，golang是引用方式。

```go
func main(){
    a := []int{1,2,3}
    for _, v := range a {
        fmt.Println(v)
        defer func(){
            fmt.Println(v)
        }()
    }
}
// 输出：1,2,3,3,3,3 而不是想象中的1,2,3,3,2,1 这是因为golang的闭包是传引用的
```

总结：对闭包来说，函数在语言中算一等公民。一般来说，一个函数返回另外一个函数，这个被返回的函数可以引用外部函数的局部变量，这就形成了一个闭包。通常，闭包通过一个结构体来实现，它存储一个函数和一个关联的上下文环境。但go语言中，匿名函数就是一个闭包，它可以直接引用外部函数的局部变量，因为Go规范和FAQ都这么说了。

##### 2、内存逃逸

将原本函数在运行完毕以后要销毁的变量（分配在栈上），如果还想在函数运行完毕以后使用它，那么就要想办法把它分配到堆上（返回静态变量地址、返回字符串，这两个在静态区分配，返回在堆上分配的变量的地址）。这种从栈上逃逸到堆上的情况叫做内存逃逸。

##### 3、逃逸分析

逃逸分析是编译器在编译阶段针对程序中的变量，判断哪些需要在堆上分配，哪些需要在栈上分配的分析方法，带GC的程序设计语言要是有这个方法，因为不带GC的如C、C++变量在哪分配由程序员决定，销毁也由程序员决定，不需要用到逃逸分析。

（1）逃逸策略

根据函数外部有没有引用该对象

函数内部使用的变量是否过大，以致超过栈的存储空间

interface{}类型，在编译期间无法确定具体类型和大小

闭包引用，因为闭包是传引用的

（2）目的

决定分配地址在栈上还是在堆上，在堆上的内存需要GC处理 

## 八、方法、接口、反射

#### 小知识点

1、go是传值的方式，无论传递基本类型、结构体类型还是指针，都会对传递的参数进行拷贝。

### （一）方法

1、go语言的方法跟C++里的方法有区别，C++的方法是通过虚表实现的，在运行阶段通过虚表指针的偏移量来确定运行哪个函数的，这对应的是一个类的成员对象。而go的方法是与类型相关联的，因此可以在编译期间完成方法的静态绑定。

2、方法实际上也是函数，只不过在声明时，在关键字func和方法名之间加了一个参数

```go
func (i int) test(param1 int, param2 float) int{
}
```

3、方法的调用者可以是值类型也可以是指针类型，编译器会做对应的操作。

```go
type user struct{
	name string
    email string
}
func (u user) notify (){
    fmt.Printf("%s, %s",u.name, u.email)
}
func (u *user) changeEmail(newEmail string) {
    u.email = newEmail
}
// 调用
func main() {
	u1 := user{
		name:  "cg",
		email: "123",
	}
	u2 := &user{
		name:  "lkc",
		email: "456",
	}
	u1.changeEmail("new123")
	// 编译器优化为--->(&u1).changeEmail("new123")
	u1.notify()
	u2.changeEmail("new456")
	u2.notify()
	// 编译器优化为--->(*u2).notify()
}

// 对于(*u2).notify来说其实也是在使用*u2的一份拷贝
```

### （二）对golang和C++的联系的一点思考

C++的三大特性是封装、继承、多态，虽然golang看起来是一种面向过程的语言，但是我们也可以通过golang的一些特性来委婉的实现三大特性。

#### 1、封装

golang可以通过对结构体里字段名的大小写决定该字段是不是可导出的（public/private）

#### 2、继承

（1）可以通过嵌套匿名结构体的方法来使用该匿名结构体的所有方法和字段（不论是不是可导出的）

```go
type People struct {
	Name string
	sex string
}
func (p People) Message() {
	fmt.Printf("%s %s\n", p.Name, p.sex)
}
func (p *People) changeName(sex string) {
	p.sex = sex
}
type User struct {
	People
	sroce int
}
func (u User)Message(){
	fmt.Printf("%s %s %d\n", u.Name, u.sex, u.sroce)
}
func main(){
	u1 := User{
		People: People{
			Name: "cg",
			sex: "boy",
		},
		sroce:  10,
	}
	u1.Message()	// cg boy 10
	u1.People.Message()	// cg boy
	u1.changeName("girl")
	u1.Message() // cg girl 10
}
```

结构体user继承了匿名结构体People，可以使用People的所有方法，可以访问People的所有字段

（2）如果两个结构体存在相同的方法，编译器使用就近访问原则，就像上面的，u1.Mesage()调用的是User的Message方法

#### 3、组合

结构体嵌套了一个具名结构体，这种模式是组合

```go
type People struct {
	Name string
	sex string
}
func (p People) Message() {
	fmt.Printf("%s %s\n", p.Name, p.sex)
}
func (p *People) changeName(sex string) {
	p.sex = sex
}
type User struct {
	p People		// p是一个具名结构体
	sroce int
}
func main(){
u2 := User{
		p:    People{
			Name: "cg",
			sex:  "boy",
		},
		sroce: 0,
	}
	u2.p.changeName("girl")	// 必须带上p才能使用p的changeSex()方法，否则编译不通过
}
```

### （三）接口（多态）

#### 1、如何使用

（1）interface

（2）只定义方法不实现

（3）如果某个自定义类型（struct）要使用的时候必须实现这个方法

```

```

**（4）在Go中，实现接口的所有方法就隐式的实现了接口**

#### 2、为什么要有接口

使用起来结构体->方法这样难道不会更好吗？还省得定义接口了，其实接口相当于一种规范吧。也是实现解耦的一种方式 

#### 3、注意点

（1）结构体指针初始化变量，结构体实现接口，这没有问题

```go
type Duck interface{
    Quack
}
type cat struct{
    i int
}
func (c Cat)Quack(){ // Cat类型实现的Duck结构里的方法，该方法的需要的使用者（接收者）是Cat类型的结构体
}
int main(){
    var c Duck = &Cat{3}	// 方法的接受者是结构体，而初始化类型却是指针
}
```

因为作为指针的&Cat{}变量能隐式的取到指向的结构体，c -> i

（2）结构体初始化变量，结构体指针实现接口，编译会报错

```go
type Duck interface{
    Quack
}
type cat struct{
    i int
}
func (c *Cat)Quack(){ 
    // *Cat类型实现的Duck结构里的方法，该方法的需要的使用者（接收者）是Cat类型的结构体指針
}
int main(){
    var c Duck = Cat{3}	// 方法的接受者是结构体，而初始化类型却是指针
}
```

因为go是值传递，对于（1)来说可以拷贝一个指针使用，这个指针和原来的指针都指向相同的结构体，但对于（2）来说，go语言不能创建一个新指针，即使重新创建了新的指针，指向的结构体也不相同了。

#### 4、数据结构

接口类型大致分为两种，一种是含有方法的接口：runtime.iface结构体，另一种是不含任何方法接口（空接口？）：runtime.eface，都是16字节。

```go
type eface struct { // 16 字节
	_type *_type
	data  unsafe.Pointer
}
type iface struct { // 16 字节
	tab  *itab
	data unsafe.Pointer
}
```

主要看一下itab结构体类型

```go
type itab struct{
    inter *interfacetype
    _type *_type
    hash uint32	// 当想将interface类型转换成具体类型时，可快速判断目标类型与具体类型是否一致，类型断言？
    _ [4]byte
    fun [1]uintptr
}
```

#### 5、类型转换和类型断言

1、在使用形式上，int(v) 和 v.(int)

2、只有在底层数据结构相似，互相兼容，比图float和int就能相互转换，而int和string就不能相互转换

3、类型断言是对接口变量进行操作，怀疑是从_type的hash字段找到完全实现该接口方法的结构体类型，进行断言，就如断言的两个返回值v, ok := a.(*type)一样

### （四）反射

#### 1、作用

反射的作用大概就是拿到一些运行时的数据，主要就是type和value。里面有特别重要的两个函数reflect.Typeof和reflect.Valueof，作用分别是获取变量的类型和运行时的值。

#### 4、使用场景：

json类似的序列化时tag获取对应字符串

在运行时才知道调用那个接口，类似于多态

## 面试错题知识点

1、golang传参是值传递而不是引用传递

### 什么是nil

1、nil不是一个关键字

2、是指针、接口、函数、管道、slice、map的零值，比如var i int。i的值是0，而var ch chan int，ch的值为nil

3、不能将nil值写进一个channel

4、nil可以自己声明一个值，但是不推荐

### 项目面试问题

1、为什么要用nats，不用网络编程给两个进程间通信（RPC？）



### IO多路复用



### Mysql

#### 索引

索引就像于一本书的目录，能大大地提高数据的检索效率。索引是一种特殊的文件，包含着对数据库表里所有记录的引用指针。

实际上索引就相当于一张表，保存主键与索引字段，指向实体表的记录。索引是要占空间的

create index 索引名 on 表名(字段名);

1、分类

逻辑索引：

 

物理索引



2、InodeDB的索引的数据结构为B+树

（1）B+树一个节点存多个值，非叶子节点只存索引，叶子节点包含所有索引字段（key和data），叶子节点用双向指针相连

（2）所有的叶子节点构成一个有序链表

3、B+树和B树有什么不同？

（1）B+树非叶子节点不存数据，仅存储键值，而B树节点不仅存键值也存数据。这样做的原因是数据库中页的大小是固定的，默认16kb，如果不存数据，那么就能存更多的键值，树会更矮，查询效率更高。

（2）B+树所有的数据均存储在叶子节点，数据是顺序排列的，B+树范围查找、排序查找更方便

（3）B+树的数据页之间通过双向链表连接，叶子节点中的数据通过单向链表链接

![image-20220904180913869](D:\桌面\work\images\image-20220904180913869.png)

![image-20220904182202814](D:\桌面\work\images\image-20220904182202814.png)

### []byte和rune和string

byte是uint8类型，代表了一个ASCII码的一个字符

rune等价于int32类型。代表一个UTF-8字符，当需要处理中文、日文或者其他复合字符时，需要用到rune类型

[]byte和string的关系

1、[]byte和string在底层仅相差了一个cap字段，底层的数组都是一个byte类型的

2、string不可被修改，[]byte可以被修改，要改变string只能改变string内部的data指针的指向

3、string里面如果存储的时UTF-8，则for-range的时候下标可能不连续，因为每次迭代会返回字符UTF-8编码的首个字节的地址和字节值，如果这个UTF-8是中文，可能要站三个字节

4、string和[]byte互相转换时值拷贝，

5、string和[]byte之间的转换，修改string内的内容

操作系统会将string分配到只读的内存空间中（就像c++中，char*字符串分配到代码段中）

（1）将string里面的这段内存分配到堆或者栈中

（2）将变量的类型转为[]byte后并修改字节数据

（3）将修改后的字节数组转换回string

[]byte转换为string：

（1）一句传入缓冲区大小判断是否要为新字符串开辟内存空间（0和1不分配）

（2）将[]byte中那块内存数据复制到新空间中

string转换为[]byte：

（1）创建切片

（2）将字符串中的内容全部复制过去

6、提高转换效率的方法

```go
 a :="aaa"
 ssh := *(*reflect.StringHeader)(unsafe.Pointer(&a))
 b := *(*[]byte)(unsafe.Pointer(&ssh))  
 fmt.Printf("%v",b)
```

### golang内存泄漏场景

https://zhuanlan.zhihu.com/p/469817707

### Linxu命令

查看进程

1、ps -aux

2、top

3、ps -elf

4、pstree -aup ：列出进程树形图，可以看父子进程关系

产看内存的方式

1、top

2、free

3、cat /proc/meminfo

4、ps -aux

![1663430256360](D:\桌面\work\images\1663430256360.png)

### 栈溢出

栈的内存大小是有限的，每个进程或线程都有自己的栈（1m—8m）。

栈溢出就是程序使用的栈内存超过了最大值。栈存放函数参数、局部变量、局部数组

常见的情况：

1、递归导致参数压栈次数过多，导致栈溢出

2、局部数组过大

3、指针或者数组越界

# C/C++语言

1、include<>和include""的区别

#include<>一般用于包含系统头文件，也就是库。编译器直接从系统类库目录里查找头文件。user/include目录

#include""一般用于包含自定义文件，test.h。默认从当前项目目录查找头文件。

2、中断和轮询的区别

中断是被动的，中断是由硬件或者软件发出的一种中断请求信号，一旦CUP（程序）接收到这个中断信号，CPU会暂停当前工作，并且保留现场，响应中断，然后回来继续当前的工作

![1664178040943](D:\桌面\code\images\1664178040943.png)

轮询是主动的，会周期性的检测外部事件的发生，消耗大量的CPU时间。

![1664178066995](D:\桌面\code\images\1664178066995.png)

3、线程中什么是共享的？

一个进程中的所有线程共享该进程的地址空间。堆是共享的、栈是私有的。

![1664178240154](D:\桌面\work\images\1664178240154.png)

ps：左边那行是私有的

4、如何比较浮点数

 一般float型只能精确到小数后六位（即1e-6），将float型数据的绝对值与1e-6比较，来判断是否相等（为零）。 

fabs()求浮点数绝对值，abs（）整数求绝对值。

```c
float a;
double b;
if (fabs(a-b) < le-6)
{
	printf("等于")
}
```

5、什么是段错误，如何调试？

段错误是指程序尝试访问一段不可访问的内存。

产生原因：

（1）解引用空指针

（2）访问不可访问的内存空间（内核空间）

（3）栈溢出

（4）使用以及清理掉的内存空间

**调试段错误**

（1）在linux系统下首先开启core dump，ulimit -c ulimited

（2）执行段错误的程序

（3）程序出现段错误， Segmentation fault (core dumped) 

（4）生成了core文件（ 存放在`/proc/sys/kernel/core_pattern`目录下 ），使用GDB调试。

​			gdb ./a.out core

（5）用bt命令查看段出错的过程中调用的函数

什么是core文件？

 某些信号的默认操作是导致进程终止并产生一个核心转储文件，这是一个磁盘文件，包含终止时进程内存的映像。导致进程转储核心的信号列表可以在信号(7)中找到。 当程序异常终止的时候就产生一个core.pid文件，可以用gdb调试分析出错原因。





# Linxu操作系统

## 一、文件系统

### （一）目录结构

>  linux将文件存储在单个目录结构中，这个目录叫**虚拟目录**。它不像window下是按照磁盘分区存储的。
>

#### 1、虚拟目录是如何将多块物理磁盘联系起来的？

linux中通常会在安装的第一块硬盘（根驱动器）上创建一些特殊的目录，我们将这些目录称为**挂载点**。挂载点是虚拟目录中用于分配额外存储设备的目录。这样虚拟目录就能将多个硬盘连接起来，但又给人一种是一块硬盘的感觉。

![youdu图片20220117164952](D:\goproject\gRPC\code\images\youdu图片20220117164952.png)

ps：这幅图就是一个例子，home（只是举了个例子，实际上并不能确定真实机器的home是一个挂载点）这个挂载点和Disk2这个磁盘连接起来了。其他的文件夹是不是个挂载点我现在不能确定。

#### 2、常见linux顶层虚拟目录名及其内容

由此可见/root并不是上面说的根目录，真正的根目录应该是cd /，所到达的地方。

![youdu图片20220117165329](D:\goproject\gRPC\work\images\youdu图片20220117165329.png)

（二）软硬链接等

坑、、、、、

## 二、linux信号

### （一）、工作中遇到的kill相关的信号

在通过进程号kill掉该进程时候，同事建议不要用kill -9（KILL），而应使用kill -2（INT）。但是在项目里启动的进程是以nohup方式后台启动的，而INT表示非强制性结束进程，也就是常用的”Ctrl-C“（SIGINT，终端中断），这只能结束一个前台进程，而不能结束掉一个由nohup启动的后台进程。所以最后只能用kill -9杀死进程，强制结束进程。

## Linux小知识

#### 1、用户信息

（1）用户信息一般保存在/proc/passwd文件中

![](D:\goproject\gRPC\work\images\796350903487081b8a21ddf93ffda698-1693.png)

格式如上图所示，以“ ：”标识符分隔开，依次为：用户名、加密口令、用户标识符（UID） 、组标识符（GID）、全名、家目录、默认shell。

（2）Linux运行的每个程序都是以某个用户的名义在运行。每个用户都有一个唯一的用户标识符UID，可以通过更改程序的SUID位而改变该程序的属主，sudo命令就是这样搞的

（3）为了提高系统的安全性，现在linux将密码存放在/etc/shadow文件中，普通用户不能访问这个文件，会通过一组函数来获取用户信息。

## 三、内存管理

### （一）虚拟内存

#### 1、交换空间

#### 2、优点

（1）每个在Linxu系统中运行的程序都只能看到属于自己的内存映像，不同的程序看到的内存映像不同。内核不仅为用户管理内存，同事也为用户程序提供彼此之间的隔离。

## 四、GCC和GDB

### （一）GCC

一个免费的C语言编辑器，支持C++、java等编程语言和函数库。将高级语言解释成为机器可以识别的二进制指令。

#### 有四个阶段

1、预处理

进行宏替换、将头文件展开，条件编译处理，去掉注释

gcc -E test.c -o test.i

2、编译

检查代码规范性、检查语法错误等。词法分析、语法分析、语义分析、代码优化、生成汇编语言。

gcc -S test.i -o test.s

3、汇编

将汇编语言转为机器可识别的二进制指令

gcc -C test.s -o test.o

4、链接

将汇编生成的二进制文件与函数库结合地址重定向

gcc test.o -o test

如果直接用gcc test.c ，则会生成一个a.out可执行文件，因为没有经过-o的重定向输出。

#### GCC的选项：

-E 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面
-S 编译到汇编语言不进行汇编和链接
-c 编译到目标代码
-o 文件输出到 文件
-static 此选项对生成的文件采用静态链接
-g 生成调试信息。GNU 调试器可利用该信息。
-shared 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.
-O0
-O1
-O2
-O3 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高
-w 不生成任何警告信息。
-Wall 生成所有警告信息。

#### 静态链接库和动态链接库

静态库是指在编译链接阶段将库文件全部加载到可执行文件中。生成的可执行文件较大，但是在运行时就不需要库文件了。后缀一般是.a

动态链接库是指程序在运行时链接文件加载库，这样可以节省系统的开销。gcc默认使用动态链接库，libc.so.6

**如何生成静态链接库和动态链接库呢？**

假如我们有两个文件，一个是test.c，第二个是main.c，mian.c里面调用了test.c里面的一个方法（加入就是打印Hello World吧）

1、生成静态链接库和动态首先要有.o文件，用gcc生成gcc -C test.c -o test.o

2、用ar创建静态库，ar -crv libTest.a test.o， 生成了libTest.a静态链接库

3、调用gcc -o hello main.c -L. libTest，生成了一个hello二进制可执行文件这就是静态链接库。

生成动态链接库流程

1、生成：gcc -shared -fPIC libTest.so test.o

2、调用：gcc -o hello main.c -L. libTest

当存在同名的静态库和动态库时，gcc优先使用动态库。

### （二）GDB

gdb时linux里的一款程序调试器

1、gdb可以用yum进行下载安装

2、gcc -g main.c -o main , 生成debug版本的可执行文件

3、gdb main，使用gdb调试运行mian程序

4、run指令可以运行该程序

5、start指令执行该程序的第一行

6、list 指令查看该二进制文件的源码， list n显示第n行总共10行的源代码

7、break 行号，在该行处设置断点

7、break 行号，在该行处设置断点

8、continue， 从当前位置开始连续的非单步的执行程序，如果后面有断点就执行到断点处

9、n或next，单步执行程序

10、info break，显示断点信息

11、print 变量名，查看变量信息，print 可以显示表达式的值，p 变量名，查看变量内容

12、delete breakpoints删除所有断点，delete breakpoint n，删除序号为n的断点

13、step在单步调试到函数语句时进入函数调用

14、finish执行到当前函数返回，然后等待命令

15、display 变量名，追踪查看一个变量，每次停下来都显示它的值

16、undisplay 取消对之前设置的变量的追踪

17、backktrace或bt查看各级函数调用及参数

18、info locals 查看当前栈帧局部变量的值

19、禁用断点或监视 disable break/display 1, 禁用第一个断点或监控

## select和poll、epoll区别

同步通信和异步通信：

同步通信是指在发出一个调用时，在没有得到结果之前，该调用就不用返回。一旦调用返回就是已经得到返回值了。由调用者主动等待调用的结果（挂起等待）

异步通信是指调用在发出之后，这个调用就直接返回了，没有返回结果。当一个异步调用发出以后，调用者不会立即得到结果，而是在调用发出后，被调用者通过状态，通知调用者，或者通过通过回调函数处理这个调用。

阻塞和非阻塞：

阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回。

非阻塞调用是指在不能立即得到结果之前，该调用不会阻塞当前线程。

**要点概括：**

​	IO多路复用是指单个线程或进程能够同时处理多个IO请求。

select调用主要统计有多少个文件描述符需要进行IO操作。缺点是内存开销大，支持文件描述符的个数有限。

poll和select调用差别不大，底层是一个链表，支持文件描述符的数量无上限。

epoll更高效，底层使用红黑树加链表，避免了大量的内存分配和轮询

### (一)select

在一段时间内（timeout参数）监听用户感兴趣的文件描述符上的可读、可写、异常事件。程序会停在select这里等待，知道被监听的文件描述符有一个或多个发生了状态变化。

1、函数原型select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)

​	nfds：需要监控的最大的文件描述符**值**+1

​	







# 工作收获

## 一、犯错的知识点

### （一）slice的遍历删除

错误做法：

```go
// args := []string{"aa", "bb", "bb", "cc"， “bb”}
	for i,v:=range args{
		if v=="bb"{
			args=append(args[:i],args[i+1:]...)
		}
	}
```

正确做法：

```go
	for i:=0;i<len(args);{
		if args[i]=="bb"{
			args=append(args[:i],args[i+1:]...)
		}else{
			i++
		}
	}
```

原因：range这种方法对 i 的更新有问题，如果遇到了要删除的数删除以后还要增加，如果遇到要删除的数字是重复的，那将不可避免的将 i 多加了几次，将会出现painc错误，越界报错。其最主要的原因还是在range之前，已经确定了循环次数，所以i删除以后还是会持续增长为原始长度-1，访问越界报错

### （二）函数内先加锁再调用一个内部也要加锁的函数

不能这样使用，函数会被卡住，外部的函数已经使用了那个锁，内部要加锁就先要等待外部释放锁，单北部函数正好处于临界区，就会陷入一种死锁状态。

### （三）关于init()函数了解不够清晰导致遇到要调用的内部函数为nil的情况

#### 1、遇到的错误情况

（1）使用空白标识符重命名的导入可以让这个包里的init()函数被发现并被调度运行，这次所犯的错误就是在gamed/marquee/impl包下编写了init()函数，并在里面注册了要使用的函数，但是并没有在gamed下的ready.go文件里导入这个包，那么这个init函数在程序运行之前就不会被调用运行到，此时init()函数里的要注册的函数就为nil了，程序运行到这个函数里出现painc。

（2）第二次遇到的init问题，在某个进程里注册的函数，只能对在这个进程里调用它起作用。如果别的进程想调用这个函数，那么这个进程也得去注册这个函数才能使用。

（3）在项目里除了要导入自己所写的impl包下的业务逻辑代码的init()函数还要导入p开头的每个模块协议处理部分的init函数。也就是将这两块的init对应的包的路径导入ready.go的import里。

#### 2、init()函数的相关知识点

（1）init函数在main函数之前执行，没有函数能调用它

（2）init函数常用来初始不能使用初始化表达式初始化的变量，在工程里最常用的是初始化一个函数

（3）golang对没有使用的导入包会编译报错，我们有时只想调用包里的init函数（在sigma里常用来注册函数），最好的方式就是使用空白标识符。一个工程只有一个main包，sigma项目规划的挺好的，对于具体要使用的包放在具体的.go文件里import使用。对于只想调用init去注册其包内的函数的情况，都在要使用它的进程（gamed、mapd等）的ready.go文件里注册。

**ps：**其实在普通的编程中一般就是编写个函数，要用这个函数的包把函数所在的包导入使用就行。但是sigma的项目是一个大包只对外暴露接口，函数的内部实现都在其子包impl下实现，所以就得先在init函数里注册它。而在其他包里直接使用这个函数导入的只能是大包，但是没有真正的去倒进去impl（init函数所在包），所以还得要调用到这个大包的init函数去注册这个大包里面的所有函数，不然就是painc，函数为nil。sigma划分了一个reapy.go文件专门注册要使用的函数，这点做的很工程化。（init--->初始化这个函数（联系第（2）知识点））

#### 3、Go程序初始化和执行的顺序

 Go程序的初始化和执行总是从`main.main`函数开始的。但是如果`main`包里导入了其它的包，则会按照顺序将它们包含进`main`包里（这里的导入顺序依赖具体实现，一般可能是以文件名或包路径名的字符串顺序导入）。如果某个包被多次导入的话，在执行的时候只会导入一次。当一个包被导入时，如果它还导入了其它的包，则先将其它的包包含进来，然后创建和初始化这个包的常量和变量。然后就是调用包里的`init`函数，如果一个包有多个`init`函数的话，实现可能是以文件名的顺序调用，同一个文件内的多个`init`则是以出现的顺序依次调用（`init`不是普通函数，可以定义有多个，所以不能被其它函数调用）。最终，在`main`包的所有包常量、包变量被创建和初始化，并且`init`函数被执行后，才会进入`main.main`函数，程序开始正常执行。 

![ch1-12-init.ditaa](D:\桌面\work\images\ch1-12-init.ditaa.png)

### （四）、注意判空处理，防止出现下面代码操作nil指针或nil结构体导致程序崩溃

### （五）、工作中遇到的项目bug

1、goland关闭的时候并没有把gamed、mapd、onlineserver这几个正在运行的二进制文件关闭，导致重新用goland起动服务器时候导致运行了多个gamed、mapd、onlinserver等程序，导致数据混乱，客户端无法登录。

### （六）、json相关

#### 1、json解码之后没数据

json要解析首先字段要是可导出的，首字母大写，json字段解析不出来有两种原因，字段不是可导出的，字段的标签跟传输方的标签不对应。

## 二、代码质量提升经验

### （一）注意函数调用的开销

如果一个函数只有小几行，那就把它拆开，因为函数调用是有开销的，上下文切换、堆栈开销等。

### （二）先判断，将最大可能的情况放在前面

一般可以这样写：

```go
if false {
    return
} 
//执行想要执行情况，非预期就直接return了
```

### （三）写一个获取值的函数最好格式（v-ok格式）

一般可以这样写，给一个bool值用来表示是否获取成功（true），这样也方便调用者判断的到的值能不能用

```go
func GetValue(key type)(type, bool){
    
}
```

### （四）将结构体的方法和函数结合起来

```go
type Stu struct{
    k1 type
    k2 type
}
func newStuMng()*Stu{
    ins:=&stu{
        k1: make
        k2: make
    }
    return ins
}
var inst = newMng
//方法
func (m *Stu)Getk(param type){
    
}
//外部调用的函数
func GetK(param type){
    inst.GetK(param)
}
```

### （五）以注册函数的方式替换项目里的swith-case

1、声明函数类型：

```go
type funcName func(param int) error
```

2、創建一個map用来存放函数以及对应的类型，v为类型，k为函数

```go
var funcMap = make(map[int]funcName)
```

3、创建一个注册函数

```go
func registerFunc(opType int, f funcName){
    funcMap[opType] = f
}
```

4、在init函数里调用注册函数，注册真实要调用的函数

ps：为什么要在init函数里调用注册函数看init总结一章

```go
//ps:例如有函数test，以及它的对应op
const op = 1
func test(i int) error {
    fmt.Println(i)
    return nil
}
func init(){
    registerFunc(op, test)
}
```

5、创建一个处理函数供外部调用

```go
func HandleFunc(opType int, param int) error {
    f, ok := funcMap[opType]
    if !ok {
        err := errors.New("fail")
        return err
    }
    if err := f(param); err != nil {
        return err
    }
    return nil
}
```

### （六）注意尽量少引大包，少引包，不同进程最后不要互相引包

（1）比如mapd和gamed之间进行rpc调用，mapd用来gamed得一个常量，就不能直接给mapd引gamd得常量所在位置得包，这样会使得mapd的代码膨胀，而且一个进程引其他进程代码定义的常量或代码这本身就不合理。

（2）对于同一进程里，一个模块里要被其他模块调用的函数应该是可导出并且定义在外层文件里，而不是在impl里。impl文件夹是真正实现这些方法的地方。这样被其他模块调用的时候可以减少被引的包的大小。

### （七）不能使用硬编码，注意函数命名及函数内的变量的准确性和统一性

（1）对于硬编码要定义为一个常量，而且常量的命名一定要是详细的易理解的。对于不需要导出的常量首字母应该小写，这块与C++不一样，C++定义常量通常是整个常量名都是大写的。

（2）对于函数的命名一定要是准确的，易读的。对于函数内的变量命名应该与这个函数对应。比如要实现一个减少物品数量，函数名就应该定义为reduceItemNum，物品要减少的数量定义为reduceNum，这样更准确，也更好读。

## 三、项目相关

### （一）alliance_router里的注册函数的使用

1、impl.RegisterProtoProc( )，使用要配套ipc.SrvPost( )，而service.RegisterTransServiceMsg( )，要配套使用ipc.Post( ) 

### （二）项目里修改玩家名字会给本网关的所有玩家广播

这里会有问题，以后的架构时多个gated接gamed，如果玩家从第一个gated登录进来修改名字，下次从第二个网关登录，那么第二个网关里他的好友或联盟内的人就不知道他把名字已经改了。

### （三）主城相关

1、现在移动单个建筑和移动多个建筑都走的是批量移动建筑的协议，内部逻辑区分

2、目前科技的配置没有0级，注意降级的时候0级是肯定读不到配置表的这种情况

3、建筑资源产量要有农民进去工作才会产生产量。

### （四）定义协议配表相关

#### 1、协议相关

1、定好的协议生成代码以后，如果要修改这个协议的名字，得先去help.proto里对应的旧协议名的那一行。

#### 2、配表相关

1、在data/convex/metaxml下找到要编写的文件，在该文件里面配表

2、点击生成excle.bak

3、将生成的excle文件和改动的.xml文件提交，只提交自己改动的，提交的时候注意检查一遍（吃过亏了）

#### 3、xbean相关

1、xbean是生成的哈希形式存储的结构

2、如果不是高频使用的，不要定义到base里去

3、xbean的map的k不能是int类型的

### （五）腾讯云上部署的项目资源位置

1、test2的日志是以zlog进程启动起来的，test2在13这台机器上，但是zlog（gated、onlineserver）在14这台机器上，进入进程服务资源（配置，可执行文件、日志等资源）存放位置的快捷指令是gg

ps：gated和onlineserver的日志在14上，而gamed和mapd和其他的日志都在13上

2、json要解析首先字段要是可导出的，首字母大写，json字段解析不出来有两种原因，字段不是可导出的，字段的标签跟传输方的标签不对应。
3、客户端登不上服务器的一种原因可能是au服务挂了

4、内网（test1、test2）以及策划（cehua1、cehua2）等都部署在13这台机器上，其实只有它们的chatd、gamed、mapd、zlogd和db(cache （redis）stronge db(mysql))。但是online和gate一直是布在14这台机器上的。

5、跳板机的密码是固定密码加opt。

​	trunk服务器的地址是10.20.39.6	

​	海外ob分支服务器的地址是34.145.111.184

6、部署海外服务器的步骤

（1）要先在jenkins同步外网工具job选择ob分支，先打一个ob分支的sigma_server包，将这个包中转到10.236.100.163这个中转服务器上

（2）在运维jenkins上将服务器资源推送到OPS

（3）再由运维将这个服务器在海外服务器上部署起来（刷新）

（4）登录就好了

### （六）关于服务器部署的相关经验

1、在操作服务器的时候一定要先拷贝一份配置的副本，不然操作失误以后一地鸡毛。

2、部署的服务器起不来

（1）先排查是不是配置问题，zoneid、gameid、group、这几个字段看一下几个进程的配置文件是否一致

（2）再看gated的handshake和port

（3）netstart看一下各进程配置文件里的端口号是否冲突了

（4）如果配置都没有什么问题的话，那就得再看看依赖的进程服务有没有起来，au、db、mq等是不是挂了

### （七）Actor模型

​	actor是一个实体，具有强隔离性，弱一致性的特点。它有两个最重要的部分：状态和mailBox(邮箱)。

有三个特点：

​	1、可以创建其他actor

​	2、有mailBox，能向其它actor发生消息，每次只能处理一个消息，新来的消息会存储着mailbox里

​	3、可以指定下一条到来的行为(那个消息来了以后该去调什么函数之类的)

actor只能发送消息，不能改变其他actor的内容，每个actor都有地址，所以才能发送和接收消息，地址可以说内存地址mac等等，一个actor可以有多个地址。

### （八）服务器异常相关问题

1、很多机器人登不上去，可能是online限制了注册人数，调大注册人数以后还登不上去，可能库没清，增量超过了能注册的数量，清库以后还不行，可能是globald的库没有清

2、清库的时候不仅要清调用脚本清楚crabdb、redis、mysql、cache还要手动删除redis的RDB文件

## 四、工作积累的shell命令经验

### （一）vim积累的指令

#### 1、注释或取消注释多行代码

（1）长按ctrl键+v，进入块操作，选择要注释掉的行，键入大写i，输入#，连续按两次Esc键

（2）长按ctrl键+v，进入块操作，选择要取消注释掉的行的#，输入d就删除注释了

#### 2、快捷移动光标操作

（1）gg：移动到文件内第一行

（2）G：移动到文件最后一行

（3）w：移动到下一个单词首部

（4）0（数字）：移动到行首字符处

（5）$：移动到行尾字符处

（6）NG：移动到第N行

（7）e：移动到下一个单词的尾部

#### 3、vim标记字符串，并快速跳转

（1）标记：/str

（2）快速移动：上一个N，下一个n

（3）取消标记：:noh

### （二）shell脚本相关

#### 1、数组

（1）数组的长度：${#array[*]}

（2）数组内部的元素打印：${array[*]}

（3）数组定义最好这样定义，比较规范：declare -a array

（4）shell脚本内部把数组的内部的值当参数给另一个shell脚本传时要注意该这样写

​		sh test.sh "${array[*]}"

​		如果不加""，那么传过去的只是数组的第一个元素

（5）相关的好的帖子：https://www.cnblogs.com/mydriverc/p/8302841.html

#### 2、for循环取参数值与if结合使用

（1）if的then最好规范一下，不然容易出错，那个bug最好没有复现，不确定，但是写规范一定又好了

```shell
for ((i=0;i<N;i++))
do
	# 例如i代表的是程序传入的第几个参数，要想取到这个参数值可以用 ${!i}
	echo ${!i}
	if [ ${!i} = true];then
		echo "true"
	fi
done
```

#### 3、shell脚本里对于拉代码等想起情况的可能返回的错误要进行判断

```shell
ps:
git pull
if [ $? -ne 0 ]; then
	echo "error"
	exit 0
fi
```

##### 知识点 $?、$!、$$：

​	$？ ：功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。

​	$! ：当前进程的pid

​	$$ : 当前进程的ppid  	

#### 4、shell脚本里的函数没有参数列表这个说法

```shell
function test(){
	s=0
	s=$[ $1 + $2 ]
	echo $s
}
```

#### 5、获取当前脚本的父目录的绝对路径

path=$(cd &(dirname $0);pwd)

dirname命令作用：去除字符串中的非目录部分：

```shell
# ps: 获取文件test.sh的父目录的绝对路径，pwd：/export/game/test.sh
如果知道路径直接输入即可
dirname /export/game/test.sh
输出：/export/game
```

#### 6、截取一段文件（sed相关）

sed -n '/2022-01-19 11:00:07/,/2022-01-19 23:59:37/p' onlinenum.log > temporary.log

ps：sed相关

删除文件首行：sed -i '1d' a.txt

删除前100行：sed -i '1,100d' a.txt

删除尾行：sed -i '$d' a.txt

#### 7、自定义分隔符，一列一列的分割文件（awk相关）

awk -F "|" '{print $7,$8}' temporary.log > onlinetest.log

#### 8、将文件里字符串格式的日期转为时间戳（linux的三种标准时间格式）

```shell
touch date.log
while read line
do
     date -d "$line" +"%s" >> date.log
done < onlinedate.log
```

**linxu不支持自定义的时间格式转换**

linux三种标准时间格式：

①、 06/12/2018 07:21:22 

②、 2018-06-12 07:21:22 

③、 04 June 1989 

④、Sun Jun  4 00:00:00 CDT 1989

#### 9、将两个文件合起来Paste



#### 10、远程指向另一台服务器的shell脚本

（1）这是两台服务器间建立了公钥

ssh -l user ip "cd /脚本所在目录/; sh test.sh"				

（2）用密码访问

 sshpass -p 密码 ssh -l lisha 172.16.57.83 "cd /mnt/data/medical-swarm/; sh gateway-st.sh start" 	

#### 11、用shell脚本操作mysql数据库以及export的作用

示例：

```shell
#!/bin/bash
  
HOST="0.0.0.0"
PORT="3306"
USER="game"
PASSWD="Zl@123456"
export MYSQL_PWD=Zl@123456	// 1
DATABASE_NAME=$1

mysql -u$USER -h$HOST -e "	// 2
show databases;
create database $DATABASE_NAME;
show databases;
use $DATABASE_NAME;
reset master;
source /export/game/sigma/servers/outdata/mysqlData/$DATABASE_NAME.sql;
show tables;
"

```

（1）mysql不允许明文密码访问

原本是`mysql -u$USER -p$PASSWD -h$HOST -e` 这种方式访问数据库，但是报错，mysql不允许这种以明文密码的方式访问数据库。可以通过export命令修改在本shell运行时的MYSQL_PWD这个环节变量的值，以2这种方式操作mysql

（2）export在shell中的作用

export可以增加修改环境变量，但是只对定义这个环境变量的shell的子shell或其他程序起作用，对本shell不起作用。（其实就在界面就是一个shell，./test.sh执行一个含有export的shell脚本，这个shell脚本启动起来就想到于启动了一个子shell，对界面这个shell不起作用，但对子shell起作用）

source对可以影响父进程

**`这块还是有点糊涂`**

### （三）工作中遇到的shell指令使用经验

#### 1、grep相关

（1）筛出名为process的进程的pid

```shell
pid=$(ps -x | grep process | grep -v grep | awk `{print $1}`)
```

ps -x：显示所有程序，不以终端机来区分

ps -aux：显示包含其他用户的所有进程

grep -v：反向过滤，显示出了grep以外的行内容

awk `{print $1}`：截取到第2列的内容（pid）

#### 2、重定向和追加

（1）out > file.log (以覆盖的方式重定向)

（2）out > file.log（以追加的方式重定向）

（3）重定向文件描述符：比如 nohup ./test > test.log 2>&1 &

第一个&不可少掉，linux下一切皆文件，如果去掉1就相当于一个文件，而不是标准输出了，1-->test.log，2--->1，相当于2也指向了这个.log文件，这个文件里存放标准输出和标准错误。

#### 3、stat，显示文件和文件系统的状态



#### 4、ps命令积累

（1）ps -f查看当前进程的完整格式信息

（2）ps --forest：显示当前进程间的继承关系

#### 5、sort命令

（1）-t选项：指定分隔符

（2）-k选项：指定以第几列的数据为基准进行排序

![1644981319(D:\goproject\gRPC\code\images\1644981319(1).png)](D:\桌面\code\images\1644981319(1).png)

（3）-o选项：把排序结果输入到原文件，**这时候重定向是没用的，重定向的结果是一个空文件（sort -n datafile > datafile，这是错误的）**

正确应该是

```shell
sort -n datafile -o datafile
```

ps：举一个复合的例子（这块坑了英国老哥，学艺不精啊）

![163065a29693bd1aedcb6ea190ef683](D:\桌面\work\images\163065a29693bd1aedcb6ea190ef683.jpg)

```shell
# 这个题大意是，datafile文件时ls -l命令输出的，ls -l命令是排过序的（升序），但是该题要按照文件大小降序输出五个文件名列表（total==5，这就五个文件没多余的了），但是文件第一行是total 5 要删掉这一行
sed -i "1d" datafile | sort -nr -k 5 datafile | awk '{print $9}'"
# 不用sort -t选项，默认以空格或制表符分割的
```

#### 6、""，''，`这三个符号的不同之处

单引号和双引号都能关闭shell对特殊字符的处理。

区别：

1、单引号关闭所有有特殊作用的字符

2、双引号关闭除$、`、/（反斜杠）这三个字符以外所有特殊字符

3、单引号内的字符就是其字面意义，阻止shell替换和解释特殊字符

4、双引号内的字符解释为一个整体回进行变量替换

反引号在linux里起命令替换的作用，将反引号内的字符串当作命令来使用。

命令替换是指shell能够将一个命令的标准输出插在一个命令行的任何位置。

ps：例子

![1645241290(D:\goproject\gRPC\code\images\1645241290(1).jpg)](D:\桌面\work\images\1645241290(1).jpg)

#### 7、压缩文件指令

（1）tar

tar -cvf file.tar file1 file2 file3：将一个或多个文件压缩为tar格式

tar -tvf file.tar：解压

tar -czvf file.tar.gz dile1 file2：直接压缩为.tar.gz格式的（.tgz）

tar -xzvf file.tgz：解压.tgz格式的文件

（2）gzip

gzip file.tar：将tar文件压缩为容量更小的tar.gz格式的文件

gzip -d file.tar.gz ：解压	（.tar.gz--->.tar）

#### 8、nohup后台启动命令

nohup ./test > out.log 2>&1 &：将标准错误重定向到标准输出，再将标准输出重定向到out.log文件，将test程序以后台运行方式不挂断运行。

#### 9、利用进程号定位进程文件所在位置

（1）ps -aux | grep process：找到该进程的进程号

（2）cd /proc/pid：进入到该进程运行的文件夹

（3）cd cwd：进入该进程所在文件的真实目录

#### 10、basename，拿到路径(url或文件路径)最后一个文件名

```shell
例1：
basename /temp/test/test.txt
输出：test.txt
例2：
basename "https://baidu.com/out.js"
	out.js
例3：
basename /temp/test/file.txt .txt
	file
```

可以看到basename的作用就是找到字符串最后一个"/"，输出后面的内容，如果第二个参数指定一个字符串，则会在结果里过滤掉

# 杂项技术

## 一、protobuf

### （一）介绍

protobuf是一种语言无关、平台无关、可扩展的序列化结构数据的方法，可用于通信协议、数据存储等，是二进制格式。比xml、json这种文本格式的更快更小。

### （二）安装

#### 1、下载protoc安装包

##### （1）下面是一种通过下载安装包的方式手动配置安装protoc的方式

①、地址： https://github.com/protocolbuffers/protobuf/releases 

②、将解压后的包放在合适的地方，并在环境变量path中添加到PATH/protoc-3.19.1/bin（protoc.exe所在目录）

③、检查版本：cmd--->protoc --version

④、将bin下的protoc.exe拷贝到GOPATH下的bin目录里。**至于为什么这样做我现在也没有搞明白，只知道如果没有放在GOPATH/bin下就会显示protoc无法识别**。**原因不明，猜测是环境变量设置的问题**（但是重高了一遍感觉不是环境变量的事啊。）

![1640710404786](D:\桌面\work\images\1640710404786.png)

我将path下protoc-3.19.1-win64的环境变量删了，在cmd下执行protoc还是能显示。再继续删除了protoc-3.19.1-win64这个文件，在cmd下执行protoc还是能显示。直到删除了GOPATH/bin下的protoc.exe。在cmd里终于识别不出来protoc这个命令了。我猜测还是环境变量的问题。得找个时间研究一下环境变量。

i：调整了环境变量的顺序（将path下的protoc-3.19.1-win64调整到GOPATH/bin之上）以后删除GOPATH/bin下的protoc.exe文件，cmd下能执行下protoc命令。看来跟环境变量的顺序还是有一定关系的。

![1640710395619](D:\桌面\work\images\1640710395619.png)

ii：将GOPATH/bin下的protoc.exe复原。将protoc-3.19.1-win64/bin下的protoc删除以后还是能显示protoc命令。看来cmd显示protoc只要能在环境变量里找到protoc.exe的位置就好了。其他的不管

iii：删除GOPATH/bin下的protoc.exe，但是生成go代码不能执行。从结果来看，要执行生成go代码的命令GOPATH/bin下一定要有protoc.exe

![1640710415004](D:\桌面\work\images\1640710415004.png)

##### （2）如果go的代理设置正确的话直接通过go get拉去到GOPATH下的bin目录里

安装proto库：go get -u  github.com/golang/protobuf/proto ，这个proto库是protobuf在golang中的接口模块

 下载protoc-gen-go生成go代码的工具：go get -u github.com/golang/protobuf/protoc-gen-go 

#### 2、获取相关库

 go get -u github.com/golang/protobuf/protoc-gen-go  

如果获取不到的话看一下自己的的go mod的路由配置是否正确，GOPROXY=https://goproxy.cn,direct，配置好代理再拉去就没有问题了。

#### 3、编写.proto文件

#### 4、生成.pb.go文件

protoc --go__out=. *.proto

在这有个坑，如果没有指定生成的.go文件的存放地址和包名，就会报错。

解决方法，在.protoc文件首部加上option go_package = "path;package_name";

path指定.go文件放置的路径，package_name表示包名   
ps:

我一般是在工程路径下创建一个.protoc文件，首部直接指定option go_package = "./hello;hello"

生成的.pb.go文件就在生成的hello文件夹里了。

![1640710485176](D:\goproject\gRPC\work\images\1640710485176.png)

![1640710467483](D:\桌面\work\images\1640710467483.png)

### （三）注意点

1、protobuf是通过编号去绑定对应数据，而xml和json是

## 二、RPC

### （一）介绍

RPC时远程过程调用。就是一个节点请求另一个节点，可以是本地也可以是不同机器

### （二）使用

1、先构造一个Serice类型

2、给这个类型创建一个方法

3、为这个类型的对象注册一个RPC服务，该类型的所以方法都放在这个类型之下，供访问者（client）使用

4、底层就是网络编程那一套参考套接字编程，只不过是方法不同而已，listen一个TCP链接，再accept等待client过来连，connect连接成功以后就可以用了

5、客户端Dial拨号连接到RPC服务器，再通过Call函数调用具体的方法

### （三）注意点

1、在给Service类型构造方法时，go语言的RPC规则是方法只能有两个可序列化的参数，其中第二个参数是指针类型，返回一个error类型，并且方法必须是公开的。

2、在使用client.Call函数时第一个参数时Service加方法名，第二个参数时定义的service的方法的两个参数

3、一个service的多个方法公钥一个TCP链接，只不过对于调用不同的方法猜测url不同，应该时TCP链接加方法名

4、支持跨语言

